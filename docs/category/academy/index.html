<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #00FF73;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #00FF73;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0E0F1D;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show"
                                title="Show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show",
                templateToggleAltHide = "Hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"deadb8b1303b84bdf81f0cf8f74c44515b1172d86e44c1c842871135b16dfa0b687ca40c61be1767c83eee0cb88482f06f030000816482551a51b80386a97e0f001e654759509844915e592d5ac575f29480005b51d580351e88ff23727960b7675a7d3a4a371b1361e6bd8b24d8ba85a20980787609929e3bb94ea5adeaf8f89e476950d42bf503715b03ded01ab1d3ad14c1b6688b2144377ada6c46f8a08c6646796787c123657de8307f208511da672ce2c7ea09b593a53a50895f37b32402274f76434fc9931393ba21469e487d429dc311e51e2a3d70672cadcc2ba1eb00b8ffca287aee9f58e93add4a8a51a30d898be6f3db46ef89b304eb0118089d508376bb6a06a031fd3bcf090dfeee3a0798a56855807a2dd703902721735bf86aae5cf829cd7543d020b1a9fc519bd35b9e6715195b733d3654456e19db9504ebe2de3d12f2d280b3238e14575ac9b50735b93f659696434fc11047282a1cbfc905126a535e2fbad50a72e809bd7785bc3ce59ded6f108121386c5428011f5ae63c70f46df6cf2370000505a31d2fe340d83b92e4746c9b03a0fbf08142ac0d28ef0c694ab0ac70dadf0f15c3f80ad11e9f3de3c12b1398717207d81151d42412a2c277442a804d909201689099ba583d4b2a83b90177421920c8f17f52fc3f31780264bc759c83843dd2deeaab293ba4314c659f9fceb89a53da7d724ea101b0fd52e2204fc65a9eb828faa856b1559366ab6e1ceca9c4f4dd45467a7acb7eff5c03b9bbc39f0be3c7853f0f04d8ad08df94a1619a4d7b20f5e40a72a06722e65555b266a69e9a666c7c4b0b1a51ac88bb5e35e8de57132061807bd86081e8eb2819cca095a9fcf02dd2a874067635f4667bbea845db0498d38b63395f6d1af9825b23bd625260800b331295fae9714c4d00f673e7e14b47800552e9adbacad9e9a455a440961a03cff7fda047f6e39e6c8e6232c3228d0cde383c46721ba3d8c2def44d2c3a85630d1336f4c52683bfe0e4ef135a0d79ff451c50cc47baa606f3d840c89eb3b922f3f72f8cfebaa63a81d41f1119b5c41ea966d2562eb66a5ac399ce7aead717bf536fb48c0ee68f7327f2343acaed4edf1ae5fd3f4891f567b818a669206957a1ee8434700d4e562ba859b9e18a886597b6f3abd092923e230ad29ebae30be1d7df34d55bbadfa0b2db691e7554a9754bb4d302ba18b1ca4d66d8c0fd68cb238b9a6199bced21d6053b4ea7bd905096d41f73e62975b89af2704343d843e046dc0cc73fbdab08602548aac7cd7bfdb783e7628ac89a59694387f974ba9b22fc17913291e527071e555662b10c12798076f4be5fc967d575de46864a917d6549bbeef3ac8cd112b2e434b7b2c42d12c721cafaf0483cc4488d10f44c8c4147a2a2907c56e2af7fd74d87d33913b0e709bbe84e370c42717a310185484f9cd5a52c4eb4cc141049d2380f87dd65f8471acc40ffb6101176e5d586b7336138bdbd3f28a2383e3ca701f6053ae0a53e1ed1aba05c56931b044b33b7c479c2fd9f402e5af2e32d75aa78b1333a0e92b6ca4ed53b05ff4d1efb3efaa1d8d6f6914746ffd630885e3647b461aa98f419339747c75bd5d27d40b87ba391dbed82f78a27520e3146a25ac44d3c1d9a53ba76577f26c347a7aec72e1327bf7aa045e54a352d928fd4500fd7c76113a5ade0f538b92d9568a407c9286c900964cb53d959bb95543cfab3ee36ba84a9678964bd58aa4b99a3963d7db61173b1cb23a4420714f97712a4664a9f4177f9256ce6a33a7ad815f0a30deb7d3eb5315049d563160a2b08caffdbb6986d7ea181ec6a1b6a425344fa6b747704bced4e1e7921b40ea794dc798708abf8abba7b0de8c89be624fadeeb17e02fe0ce495654b272e4c201a0fb88a846650490de0953fff5c85636a4c7bfc1848ba80ab0ba4f8547ccf1225784b220b0a130af251cdea04ba681e6437ac5aab3a856c4e3e17d15e2999ba07ef547f354586bf3f99d770eb90c21b603f22c1f4333c82b902b4a6e00dc2d84ccd9d4d063be454c4df24a4f88cb21a9398f70c782d017d64de0b87148b07cc172640ad155cc888ef233c433733575cc6614be454bcbd8a65d33d7f95c549cb1a0b3cf0bb5d23dfe9ea5b25970189d199c33e522450bf8cea1ba2182c374e295af88d71e148457de484706c1dad91c8426a1788d3291d214f009c2c809100cf567c0905b11e687a66d5bc105071d5339cfaf5d194ad19ba92a2f7697c863574c32bdee6e7a87968c0997fd0797546711ec098ad0820c788f269870103fe183cef516ad60fff351defac2540853c6097d8bd6dd57681662e37948b64ef5d0d88208bb3b805d587ba28e6e062d92ce4d89ec35ad6ab7558a2cd94b5c64caacd1e799dfd0ea98984207471a8047ec0489e3ea277d5cfe2c8967bd407d1f819da731274ed7f94995d75edf8397a7afbef35836586041f168eeea1b6de96ffc3ddd2707b0892fa74ec6ca3a52e69d8852c80a20e2814d5510481e9827d5bc10b34766ffd96d99033f4d04fa7e5c560624e67f48ab09384983f4ed2f6c0e4a873f9972c8878af2064035c46c22032116b400c3341c5688de905f197c8b6fab44f4d17d88c668bd5ddc660c61eb2822c641b74fff1abb5b2aece913f106b4efb11c3d1facc55b728b1df1ecee7a79ce4ab7a0c91404c6c50c445d657efc7ea87cfbd05ab935be04fe575fe0443ad676fbabb29cdb4cabb2c9541264ae70cb2b1b700986fcbc855af12ecd288ce8874f68966b4dc7fb89875a455d757525981c685b3d290bab8600dce99dd842701da477c5bb2bbaf037aa3b6bc38d282c32152016cd7ccba3c2041c200fdce5443f6b1241ebaf92113e886430d70cb6d6687948a92afcf5e142ce62bcd0828b12a4c10a9f2012c7344fc868ed95724289f4b91bb39531e12dd12a7f369dff8433f1078b58508a45ff8e995eb56a9a4d195d2f4243dd8386622a3289df1332ca66a1708b01c721d1946efbab2118e263be9ddfdec7dc356027f52c7b3fa72846b0ed6f2bcd4ce427179366182210b560c9b88eeaacf2ab266bbfe509e57279ae8949b0f08bee98c419dffd114af0babc881365fc37c52e57f5c32f64b4b40e635fc9b045cfaf8b0f2aee1147142d7a054200caf771956ef7851629233a9d1dcc0d56ee784bcaaab29206d20fccdeea794b31eb626689041481f67017c150cf34750cd7f1b91b717bb086548e401a125edd802f900314e73c11e06ae1c72768c14c0bdfd0bccdab651cf9874c99ef4069f30e1e19ab3acd9d7cc435228b607299b13410a9f1c69be15f8b127d753bd3b295dc512ca21920c19050dc4d179bc6d1d1cc36029f3e9fb14947d115a128837a7db1c6293ea472ac2db2d75e8c63ac0c1dde1c9f08a0064c3918e5150101232a2292fb165a1b413304cd8213f55d9fc3c9aa334c36c3d46b55eb3001db3a9a361090174ceb6ebdebef2a4964cf69ec3aa6ffd66b887fc365822a29c58393d35cc06f1bfd28d581f29f7e8d4e556378da61e41be9265b3438f70d8d142eb537a29a27754adebd323d2489cf850fe349a4c58503c10dac49a087c28a5b8aff75f3fcf59e53c7c9446aca7cb7b9c6d7a0fc3a1da1e22317dd0f10822faf80c6afe01d2aee9cb12b46baf61a2a1c64027db61bdfa322f40465943d34bdbeb5bbb5b250d607da4f8f14f591202240c4763ca0f153d8f43e2a6f423561aa55794afebae238c0f6c0f94865b7e96ebfe22fbfeb8a26b38353946799f2ef8eba28b673c44d609e72ade0daa0e4f90fc620654a691e909347fc1e322e234ab4a5da89f3df529f24b2949a5888fb259fa67fd1303082d9e7c3bd38e6568a3dd849b63e99e0a68276b6d42dc53279f03ddd10d346e1358eb6c990512361c9230cb9ca3e27c67660da9934f88c31c8fe5ea010fcccec10d83948bc98ade54f70e94c4e5ba8cbab0e276326b9d669ee319966342ef893d6ebb16c63a87a53baddc2af06f70d1ed4e84dfa88af07ae5803ea3f9a2397807dd5c0f504de03205d94bb9bcd55270e6381d363688cd6ae4d37a61bda4f6c5d2dceb307901f16cd8b3f7cecdba4228b7bf9e08b9f8e6fbbe539f4812019e7c3f35f6503521444c2859e7d97855b1c470b95477646043ca8fd1baf4d661b410ca06206f95f8c812e8bd7a729254762e8679a27100a2c6ff3c58dcd1b414cf8a2c56a4724d8b3532bd5a59b23491b97277864f6314f7ead53bb7a1a5d1c1f4d9d3c6ac151848139b3769552b1035d307289225aafba010d9455f914aef7e75992f236d9f818e8144c3c96ef714f0998d778005e9b0c91769b6e98058fb2c45e3e95305dedfaba2b859ce7370fbe77f128d0c3cf9893db20bfd8540933fc1df87680502b56598b70e9a9853bc1e5576be9b6acdddb6ad24f978fa428e0868629dbbca782bd4e2e5c334b9909c2d0f4a00408a8fce78e8dc83332f5f587d7a2cfde02f4c4f9bf6972e6a898c4de71f4c94eda3d91797c50023f857edb442783e04bdd57c6f1ab7dfa7a4bd20e190a156d935bf2b7782ae631d5f17f1cfd91adf45dbbf15d1cf756e1480986d8a43018cffaae85eef73d1818fb733bac014a44b925e5525fdeca5acd0fd03e5d0b0550b5b89767e5d051ce12ffee05291babe2633b5a911ea9bad06162d53148c89226107f9a1a25841da7e69b4c894b2ff430c0fcda1c354beab344d6ccc063f3a1af366e03650587a58b6bca0780b1f583001c72398f63313a3bcaad3cd1d3c0b48874b1432e728a0830fe0a2d509de873fadb99efa8c555160f5bd16e324e20f18ef9d051b0d58c4cc0a3c3b9e7e9fd28a6f9f579bc50411f3577631022801ea30b23451b4991a659c4c664e5500bc42a0dc1e86173f990d8231ffa4c6cafd5df311061f6065844defae35d958b24886871341c432ad85724d62ae5381651133c59e7e48a2f1cb7f91d0a6a5b5e3a569ab5d52c273e9fd1f6b522543aff4e6c39e90b7a52f0a84e79d80b8b2d38ead36aaee603eafed8bc186372b95ed970046c61729ef966a418194cd35107fdf1f7712a6de5f9bc627d038e883ffe6764ae5f66341ef3fc2a22212c94909d8f56fe323d8b293aee7714828aad2f67be1fea1764f9ca1e2be26694bfb25e6610ddce6ec4ea8cdc56cdef0ec1aa9093b654710fa4a1ff4fdc31fe4de1c13b90b705beb85bb6bb7dde8116d18d095cd3e8830ad3281538631b9164450161aa75141384c78ede93e5ea2e3022a1dd8f0577870cda678448b7956fc826ae229b00372e96245c5388e593fad2eee5728e426973fb0c6c7aad28c0dcc1530f5a8876e0a1c358c652f9eed09dfc4fd449f93e7694b61caa13eccc0c28d48c8b9c476549b81a6fc57b92b37c08951da6348dd9ee582ff1d7ca6ef330100b0def9306563da5418398842f9c4d94422a8a0adbb17d6f0e8b84e4640511c28ecba116d8490d9b6bffadab6f875eadcbfd8c32a18a39eae5ecb87d6b98fde83407af3be5b52caaa513ef8d03adfd31a2d9926982d94bc76b55e26960a930bfd0ceaebaf6b5ae43017e687f15bb3db32139934188f9ad9ea25fcb96549292d53ec59255fc3b2c483785998c6facfa2c01eaa63d7a73e2729c050cc96380b6ffc89848ca48dd452b6a506a361ca03bd70a794fe3ebef7388be19751ddc07589934684cf0428253f4d65b8230eb2571e74a0ae7cb32cae27d6d5ff9a96dfc5ab2772a99f15cfd96b03b4695e97a8402177c6b508795d1521d9a9976c1ef3feb4a7fdd458a88d24d2b9858a072e9fe562f7c4579851f8a58efea0489fab0d11c27e6ae8e48a159ffa2557815f8b9ae09672a95af9743251f861f30003b0fd0b20dc91160610674394d4becbfc5a67e3b394b4d59499061d023f4e94ebe283cd6902f07bd3c97921d0c63598fd6e077df98eed1a68fcd7e97b495422e03521c86ddc6042924402cd6ebacee83d9ebed37e5403b6b54dadfc5e8b23bb7af81e0f30eb32d94f57e45dbb86db3d39c3d4f5eb30f0c7bbfe9e30a6c642fab24eb63f84f4310daa713d97902a78306f0d408908c837c00c685e2688e25445e081cc3bf06750263e0abba3c58619068f77abd94edbb65970c6d7014bec2fd2f413b41cd5cbc54694c1b74fa6f618b0fb1e5fea225660f2099ee8b14e92155467edb170c85eb4b21575e108226da87181ec49423f114d7207edc6530180d6387277121695830dac219c59a941920df4f2699521ae92a4430b36572094565dbb0a94ec1ccc098d4e22b57d4608aa020476ae623318dcd8d764c8f77689a8e21c5a616970ccf35db4bd563a4307ff2b5a847e0d5df572c560d2e0fe5e0c5849100b5cd8bf9287310cbe062369b6a83aeaaa86e5976f608171e8ffad4c6c651734a3f2b0dc6e1f036e3c722f146ef90e2718ccb170c29f0138673d1990218a1660f1826816d069304499060d78c36dcf721e3571437d5c9e52b9558f72485abf75bb3719f6280790f428d1e3215a3f57f3777b89bf962e71857193f6a050ec0c129cd6e0da20fd40fc489f31ad576de14e05c1d84d25fa27c57f3fe1090becd0d4ba9589dbb25366bae3327522f15edc08ac034137339e84aad05dc84aabded640ed2b72a181e4dd196b6a53e5ead8c0f681e8e92b5003bdc5621f5f77ab7071f337015ef59b8d2428c178ed36de4e20b0a990bdab83e51a1bc2dd687bbe915ee09bf5c2a44fe416fa0317b6d18b02006db2e91365d421a7e3136051b170281b945a884ed8ceeac33e46e1e2ac128f79b4e595cb70845ceb2d145ec9352b4df329192bb397b5c0fd518bf2f1feaa01b1542940cafcf13102f8b4d03a9f0635e0e0da3384a94ac798e9cba5ca00081e17bc5b819928664e3aec81a75168b46a6f0aad8cc2df2c44aaab7d32badfe82882321a30b23cd816febaa0960346f628d1581759791796ec9c05477b1e336862b81d707e69e4348101e4bcea5f21496cefc0c620198ba5f3c41684a359a5aa873be39027423b1f795b5d4629f6564b8cb3d903996bb53b655bad92b366f78aebbdd27aa7b70e4e854d05ce359e506d8fba5788ae5066d1b0ff7252c45b5a6e453d425d2b7a85ca58e1e3f32c905b377c54054abd05e04cf97987239404ff3350a300b1b2e199c0ccc52bd1393ed178b440b1f28952b9ebe5ff828f915cb200c33f0dcefb8547b3502a845f9d0d1cffb179db6b77184d74793f8323fec18711252bdb8b3d06ef7af098c5e07240d9d646d7a436c69e76a382cbbc6916e3ad4553ba159abfb33900f61a304eda0bb0ccd898297868b8fbe2acb3883c3b618d82af15a42d44e128ebb9267f206a048d3a69754fe07bdac4325035b3eedbd7f716a2a2b5fe6043b8e9ef7fd127945f3b03e044122fcab95d97d6fd3360a358749139cdc8075b1f8100b22fc7ba1276498217c3b201889a9415a972a3edb7c0d8a8250d81f9ff8f3697a42db588ef91ad843e1a1ea81ccf4dfc82d8bda16f2e79b295699c90eea6acdd85d426fa9892acffd744200b45a427ce2e1de88dcb042aaf82666e17716a0767550aa6ca34477621b50d7431b50a23a5a69efc4460fd5587d0dd964eb70719ea0e87ce92d770bc840bdf3b6faa904bb6be0e87482fe8ccb8557af7070f448acb379101e590f969636f500d809fc28395f662bcc4f8dbb5d8f0067d2e8faaeaa426cb511c4681dc8096326e69cd967d968161c54a3a50267b62a79d95001912957aec2bee4a791476bb6b8a4de6b030d755a31428793a334cbfb1ab7833793dc48edf283c9946f8aa08cc9a072c0998755b775c87728a5b2deab505e44af9c17145d907613970cc804330e5fb5c1ce25f88c3b8067a5ff8ce699ac8b9a987a4907b690e8f07c51ce34e74694fb587a0bb05f6d1b703436e529796082b827f57d6d2a0f918ed613fcb89f7467766b78b2a15e200dd51c69096c18c7226f39c5f7eadf9b41459b92b313ff776033c9fb1ebe3aeb6f95e7121cf42b54e65f6b60aadcffd4d9ef091684f9a823946aed67f97caad84335e3710d74620a0b5dc181f9b89dc977c660f438c446ddc51b079f28cbc7108c47a55200fc1615475aee6fba01d7cbf71a178b104ef82057dbbef3d17e23fddd580ef7b9f8e5f2b26523a3d69372a29a5ee42b0e2cba25ad35655aa9a0703628de6a39f909c3590bc816f0b7fca2f2db84e7fe4590fa7437a811ce38afbde79fb5aee97fb3fb35d258773227adeec18ddae4e1c6d15f26196b84c6a9c107f7d07b2cf9b79b41862f2c25f076abd897b5703040b855203521035bb83811c564ccd03a97a6815deba9ee653617be852b970b3b70da7f6f300458dffc239753384ce94e26ef111b89211cf283b9acd4157dc6c63275068ca6ba5f807d5f22eab6b854dde5508aa28f7345d7db927074d0692ab26d516b5dd0ea39bad89079454ca273888030ef523e4e5a584cc35fa4d97fbe6523e5756616d4d85cbe098260023435114a7eff591fb354f6f0f3a7e38eb2e54b8ba031baf96be2e447d0484b3f95dff2791881e56f1edfb3a4eae018ddaa138b0fed2f52463d1acaff57396d66f460ed34afbc8535300a4518c2f79abf44b0cf9d344b10eb3abb02cdc1ee7c22b650228eec3c42daf7c3022054fb63a223fc19b4937d583168592fef39efa8aade3c094d47ba1e57f0e57a30264452871dc7f81de8c7faf3ebf601a92098abdc3678452dca94842744e1c7c5abe52bd29bdd54816f2d7030da20033d0cd668335945cdd1515ff84da377069feaae44b7253ae72e92d34d58e12f209a4d438e6ef23c00d5bcbeccf00e0a8f09bb3edae04fce137d958b132f651774e3de8bf36ad760fa1d9b4e26c972f74cc2007c084eee6938912031c5ac53b7e15c041ead1a0307c950eac7551c2bfcb3241096391a7fe122f76b18d00e7d439688d757f287e84e98f9775bc5c76108d12a75a46c66a1b798246d8b505706a8a17ad485073635db4e677a3a4c24cde005d6dd644a3a40a93f3000101461ad0eb74c4470b553b95215c64579748d4d62226f95cca2286f4e5b0b44cd808ee18fe03c4b4d0d0f01b7852d50e9c9c02e50cbb17874cc03de5e41234e1a72618dfa52cddb68e6b47c711fa97b303dae4d7ab69288049bbc81f864425156a90b42d773bb05017f2284ed10b35e148afe65627a5a0246922ee3cc0a40efec3d79503d782dd55f21b44b7c78e4db217260088f6f1657dcffecdf676394a4a8cde104425d40d14963ac68da1e9720d4efd6fa1dc5b2bb035033d27283d72b102d337b585508a7a6272dbb780e2c8fcae9346b8c94dac75ea1a10d17f6890bd241736f62be3994443bd2a6b3eb7ddcd98c02b849a40ffbfb5c61a2a84f74ee9389fee636ef14d293748bdd9b55e60c674a503bb18cc91bd8170f8dcbca4fba5264657c9682f08eb638af8e6da36f47db204b203b3ccc45b9f56e40e57197983689feddfbebd8756e4a204b46a70dfa31c2040ddecb52bd71fc239fab770b42fee8c0965526d45d1d577f7d62562cded266fc84fe4d63c564009cff8dc9de8e152e5e889b04631cef7771df4330467db3239559bee50ff965b0b81afbb7fd6ea8362010fbe0b9025bb4a73065f522d8403fbf72f2b47cf55f7bed0be4d852a1a5e47a66e7e407787165dea8e933ed781785d142f84279bbd32edf0a66a974e10d35269ee063e130e8ea789003866dc9f72db8a3a2c100090f49141531133c680cca26508e94181835d8d1568b50e6976c36067baacdbd53f5ae5ff6053732734db071d0abc43aaef0cd01ebd074588ea1d6880e7afcef89008ae88e95262612fcdae321206a36b6e1d188ac257ee655530e0ae450af9d537effc5df8372ef399b6648436db542214a14793a2e5b23812d87fd8ca712f6f621bcba1daebafa59a8c6ef2f50df224010aa77d29022c5930908058b18db4919e11a77c2430bbf5fd43462af9706df9339059ea992da5ffb4889fbec47045ab13550c742d748472f6d81c990ad06f0e9e9f423f7ecb8f427918adb427ae1b5aae2a35a88539e4f935e68fcca64a7d77ccb7651bb90dd0e329864e18c834c69c15d880865619f03353c674d5c69736f07f70d336614b7eed9f734268bb6bbe93203314917bb746b1e55264fb406199967f887022f5420cff4221602b694a4f7fb5c115e66057e95ad98b47e8708ac414d2c58bc1bfb9074171115495c6743298793a28f4654979b77d564291f0ab2f3f4c043d9a73543ab1123d8438d71d1f2d765d452bcb36c07d1948d46b360c848c17218af5f9096dac1ab4d1747dff714eaff97fbcb5989ec3f291366e5d5b0f96aebfeb87569be27379b9765b281c6dc73100c4f636a92b300850e1849496b0a3c483a8e69981cf0b2e2bde5b4b0d8c7041b176f6735519436306b63eb7edee41c1e33de7af4ecae97d96e871c18abb1b4ecedf64182cfb77d5ad0b18be605aebe4d965c471a28d994e92a4dc48ae24926e4fa4ac963cf227371560bf8f406f088413fccad981571549d17b9b02e1f72987a59e3020dff49afaf70c5a48d8e82c277e701370dcfd419f1cb1260de40b4fcbcbd53af4f9dbef17c2c722fed01427d4a35aa53ac13776c688773f22707a64e9abb84c804078cc0baa304325b6b15146dc1adc408d24fe0594277df87d8dec5fb40a1ddea8faf672dd0ff6ead9537382fa9d702e29f261018739090417787a0290959b20af0547d8349903182b6b43205a50fb4bb7daa159c7bebf36704e7a041f6a15bfb4bb270a8df0595781780727397ea19456c6ca2d9203c3883cc029d0bd590a625e4e15f9e5ac3d810c2d2a57e01e0242ca4b4ed44464ce4ce8526cc7bc7169619a2930e66751311372fee1d5656f86fe350548c4c5da39b72f141ab71724e9a72951d5146f6e94f48","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"6d2400d1bba1d7cf7a262382ad3c3b50"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
