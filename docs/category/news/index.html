<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #00FF73;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #00FF73;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0E0F1D;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show"
                                title="Show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show",
                templateToggleAltHide = "Hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dac713e6e946fc70d5520fb328423b4f15581e566195c2631eeb4465e883ea3a8198f78fb18804fd54437ecf744975c4a50514c3ea09170366c7d83910fee9c198f70bb6108d2c7374cb1dcc5e6193db9ddb4a3fbd4171e7669ab31cec0dc913330e76264b710274b22ff682d5a0c37d924041658aa25d97b99a2979dd5a04f5e9a42401a1a06da365b791a2d8da161530013a9d3c5b13c1840133daf03029de99f14b338951c8b347da1e4ab95b3c3c868c5f9f12db72f8fa217c86421623796f89de69ffe5e73f094b223ec5203ea69b46b52d6d1dabc0b8e51ca09b3349f30a17e96f8ac6867955b71a87a8b6f1390aaf8dda94227b9f5ce2a8bb3d72b11b9bfc55aaccf14df3ebf8beb83d46632e3a5a5edef5906d223c7a2f37ae7088cc24af70482aae9ba935870bda3431be6c1c547ef14d3169f39cb2f17e2313ebcba707bfaf9952ec928528336cac928376f52e6230fbce22f3143a60b258e56d50edf622a5b15ca9ca775c1df0682afed48660191f647a4a8bf35f30a526f36a01a22b4a693e981718836ac4152ebfb610295bc1976f45795e060cc7edffbb34e12a7b2414f87d7aac452f5ad5612ca691737c0a14c464c3db7cd62ac0c97857c6aca1287ba228d8ed234aa08484d7d42578b3775d63da875b3f6c09974872efeb5d9e8a5d3e6470026d4dc503a2acdf4f51171f86d0768c36ba8b5560391b546578db3d2d934cfbf3f27fd48b48a4b58b6a95e8b09db2bba371315f0f07628863a2dfa41a5d0954154dfb12bf98d0507e22ef4b9ae78591616db44198e6bd22397134aaf27333d26c060080090e53891d0c6001764dc60d0941ebc0419772a5bb4ba7c4e35243500267f371bed74c5d305ac3b7b4adea1a2ab1e412f7ea32177d6b9499303a9bef66523e442129dae649608205a8f004633f5b080347d6516fe151a2879437bafb7aefdef3a8bdeafd7da2062f5060570d9af1c0f40d0316fe8aa4f13a65809c5e92991b871aab2bfea30a0bc7bb65178986496de979d2689077c1b8cb19f3572396257c7cb057e288dd608dd8bd216cd8016b1273dc168e58730d997fcbd913c8998a7bce5bc9e8bea1d0efec723868d45fbdcb1e080f236a838bb091a7de6d3dbeb75a5aeb51df231ed5d86b4e935c23b4cab449fe8954d441c1bccbfbe1dfb6aceb643d7d933251f7177fa4373b5821a232552b1a5381ad8e611ab2226a713cf8945dcb512c7d4700850847942885b84b9a57f418ea4b615f1213b1b19a347cec270631d261055c90cd9388a04c5db58efd0b7238380b8231437fa191ce837e50b7d6ad53f056463a8ca54f348372e8c7d045de020d1d04c974c945f517e35030ac15fb73499bd4b53e1e1fe175ca67f4d4d56b0eef8e96ab62ffba22b3acf5bd3be1f0ab44d8eda60527a09b052618e89b4d6a0a477d81c894a6f85c77dceca8be4b1b2a0b0501143739bc2851717d76437ced256fdccffb48bef0d1cdac1e99241aa3b1f6ce7759d6da2823600861c8b0afe9ce1a92164e4e789ba4e30d8fa9635eb2828167a383e6b1eea86c619a73a7c5188b2c81676c1813b04d8fcfd4bd2d11a86929cac692bc5a69ce177f4b4897d435e7edcd3c75526165dd7fa6a5defe5c8c0089ae94419f41b18abd5592eec51207e1b7d963d8b77f5a463e31553450911d608bba07d74d04e08dbb761359e657fcd2369c2f629919df34740e6832533259c02ab26d9d366a01a9c9d44357e0f08c09f30f8774e7c5a04935fd1774b640177eca9c95285ef554330ec61dfdca64b98ec6f82bdbb2f744212976052f69b4ebad4ed1d0f78672f1823ef8578f149b1bafb16decf66f2839b2ea85a64f64f2eb454307e589ea74e447e68b2d35ce2b680c2a9848c670a7b7750c3d0daafb33a0d6634a726f55980da090a17c262bf560801c3eb55f3267618c95fb364bf801ff22939e2e8b9e9c9b0204ce1decffa23614314a3427ee110d4b7c9ba255ff75a4f53fece881379198c0f87bd4f3422ebf286fba0a219ebcc2e7b432a809dc3a0c4bf315d66aeefdc9f68b0168c40c3b7512441673433bfe4a285db54cfb6e8ae65fea20411e790961c27469142edf65cfbb54d0fffd9146aac6098a172d08871f964a81585c245fb4ade472aa8b860011d6b34f3cf0756d06c1a94459d50bb20462dfc3dfb2e206ec096f5036300eca04891e6e4910192e986b5c23ef45e7caceba2cc8c26fed897f791b6c03f3b5f68c00d92d94170dbaf6ce94fb7bcb0c55ef4cd1210615a2b91cec790fe98a42a3c13256215de4c4d13dd16b5a5407c931d3f59f92e17944a4fbbaf158d97f99118105ccf02b906826025d950d309a7f2047b2f3e8b5bfcda781cafd460ee810d3c338df41605e6a24320a9a4978e3dfcbca937ebf179b29d3c328beef440b15e4f61df52ad0487c1b7e2ca0fa663eae0e2fc727b695aa692c877e60e3694c7c1dac7894b61b82e47071570f4bdeafc6a0b181a64cc62dde991a55b2a80aa81f22e164a7ec6890f17cda278a1d409c7b99e254bd75fd82dcce6a3fcb1d7a6d3859324645e5f29aedc69f3f4819fb68a8830000abf47d754427664f28e71fc81f5585e3dfda4b8f0c1dadb7db503da519d579c030a4d5f51ae8708172e4b3d9c9518eb84540d82a39d65cb0b6dd387c352f0da3175134bba4ca87711457fb4292a23b972f0e2aebc60980a78c32c159571d0effebf2ff8002c5e024589e0e30ff9060babaf3465da75536e63fca3ddd3fe8a86464865079771ea58fe1d341ffedaa15ea300d427b491f928e5d6ba8c6205bcdd8d498a96d1f4715ea46311c0b61b0ac119b06baa2e5ff3ca1610efcdc9b8dc7c067d02677fd813e0211cb98231042e86eaba1896b8e87efaf61b3bb83c50483df6923013159c3f603daafc059a8c510927d098d4c94a63896ae96bcec6567c2a56f6a4ba69e60bb7aedc2c0ef880f354adc473a80874331b898598bebd97d052af1cf07864bccedd8dd65287773cca8ec51950c1ec6f359d7434ae152e79d8c4c296a3438a276bd6031452d8e97db15c958f230e387dfb7f337bcc42b7f58ed4e2c59e3177a98a62da81c2e8bcc8077dea8e8a4d85e87185662384fd0899453c57b45f99f0eec3e0ead746a3f9b6aca9c5f7e71b2d535314b65ad0539939976bd72163b40dc3809db813534dffca9752feace3b210d7520392b7a4680d37ae2bbc9577d14781f3ddebbafb593dd99b42e5534d487ba81f704c1dd6b0260fd8661fdadda2a46e88eea7799d4cb57df4bbf9518eff733700a7452be4e014f1528bee487c72ce30886a5b700189d66fb2719c7569876dfd3e4906400d401c9ef02f0088ade2c0ce5413b867bfae7c18ff49e678adfcf969e83880165d7841da7a2c1e32705f3b38ca955d6e6fc5f7cc13b39be99a8ca509122a74a8ed0185f3213105d9b7f28b5d92bfc532720a24c21dd31814917ab90289cc6f2acbaaaa8cf9526982c299f2ea290d6b0a11ba65516a99d4529559f9d08f23eedc6960b6ccfeafbe5cf3c061183084f32b24b11059a2f4004849b006e9eccc05d839333ffc7c25eb93a44bdc50bfc91e6d4f80f6c722bb9484a8d4050b28f8ed04c7730327198a331397ff83816c740a0486263ea1d119bcf15c7639bb8e6b89673aaf4dc1dd8bd0ab3649a1c4805486b0500ea42a00c6bc04abefe4be5b34731e5e463199b27a373a0d4bbcabbb3d71127c08e337d45f24128b65e17007327e623fb7d880d827a5edcc70a0dced0b5e2df930d01a8876e7c854b0c6de97b2fa2d5750b34e019e42db13a869fabd4e560acaa7c400e4d0cedcc6952eced82babacb330cd7e55871866f6b72b1641c663944e0c23716de3acc345d976af2cafcd4f8264a1e00175a20873d55ffbb84891bba309de22fb79a81913c98fd3b4a547cca09a8c7dbe07a9edcc33a093f0312a26adf0b0310299c4d3678b9920b3e5f6088171a58deb7af2f6fd811533424f5bd3aba10a6b02f6361cd460321880ec70f2d6a2c950397623e1e336c40e24619865f95cddb1c67147b853ee832b6f22140635bb308e017004a9f5fbdbadbce054fbf669e63c44c133f8c67a3fcc518a6e2e85cd8c8fc406001538edaff60bea37d4171749e6306a3581cd740cf567681a032f7958a979cf4473975c1a2c11a170c3574d1813d6e21d90a50f258c14e28a13b4db5d65b15746d63db4a694b5da5afc682422545124c3f7b4580e6c999ce12b5d534e778b192f81cc7f87b0efd6a7ed3ea8ccfac3990fa7aae3a1074412abe8542908445275b2da52d6b15d226bde16f5cec2f8403c51b071a3714a0ac38c9ac8f28f8f880b6ea0133ed6e202aab2509fd534d6ef9a33c76ebc5fec8357369a0e9a668fc75c79cd970f60424d46871c66ab6df92b639f0cd31f1fcf987a3805b8751187a4a7af46f8506dc90417ba30cac7b6fdb998eeab15851757cebf374a86be690d2e9d0d55fe9558687803d3d372a4f578119b6b0faadc73fdb211b605fdfa3fa6f0b71fce1e1aa203f2e5612a78ccd783b4e5593c7a04ad97e321b251d5cdb901c2366813c7fc1a745e12f289c48d020f606e81927d017a9ecefdff2b611fbf15a232383ec12de15513f1f2c1cd74d2fb1d101c2c99bf3aa32a9d9fff21142b55462f0bf9e70d1fe690ea6703c881bd21b2e4f699ea40d98a3ba3a3ba29c269605dfb5a68aa4af9669a74c298be43edf93d102990efcf1d85b95fcfed272e3e307976b1dcdc335ce6470dcc0b9ade0856c79aee6da074e16d1704a1c8acd2c31603d78d6c67fe0a406d53f35abb85669d8da26501159f846724067c7302f1f3f9597c72b277ebebc22b5d89bedd258c09b2f2f731326fe18786ffb1487c13b15af913483e8a619f2d0d714af4f2cdae3828cc17e3a1814f99a75098cb315c28083f02291877d777050f61557b9a4705ecb32c40311769eae9163b6b36d9ce4b2d99fd0bc033ef7be8c630224230d1ec1770fc04d1b5adca7f360441e31f8e975b93c9b493df294e8710e0ad12724b5538d07a33966cb4494493866f3c8b44b5f889c1151a64f627bbb332d12f4afe9da3a2ca458f659248e97a7666d5e298d50f55bf291e74e5e668c9c2d940ae96fffe256928a95d73667c00780c2edfc340a010a79bf12c614397592b6aa2b9beb0779f409699727eeffe0d8bc76ef80d673660dabc530838de512dbf4c25e7d10dfaa863733ecaa20557aab9031d7500c21ce54a3ac061655a80ac6177ac1048ffcc7a83dfd5ea52df40c41b0f5de8289053c3773ede242b825f330cb711f89f1b96b388bf211b9c6e94dd3a248e9cf973449f3e3ea84fa1665c8a4f0ba7c603327c3ee02b496d7b507051309974e37745d81267fd3c8549e8a6fd831ba253dcc8c8c2b6c99e876d2c275cec84e3fe4eb02202f5d44e09a926772d01d65030d0f490b9bf33c30882ebfc3a87ebbe5e601ccf93cef2cebce8814bd3a0ac7a63f86286a8c845b614b332134c3482e17b2f87e83447e43b4a6889969da48da4c8215862da79c2942d2017c2a0ff38e9c772c8a480b0aa24aa49b27dc2764e94808bb7ee256ac1022e3bcbb8f98ba2da94213a7e727187b26f4d62f61b399194a3a4533cc8f1ae6ef05715c1a7cdace568cdb46bb9cb10112a02388fd52f0d195301d20567f7a714b251d3070684b3c043573b592c3f6c1ccb6367e70eb7f07627e1e8883d49afc30f037fa6e0f1e7c4b5744ab5fa131b04e76d399137bb40dbab9ac78c2932be070ed7fbb8b641710bbebab6c79101910b9aa8e884263e7f581cab64c37e2861f9dcb2cc11656cfcc7fe7596863dca14f88aef6b87c53aa4a83ac0c50487c0724ea4bd03917c49df922ce328b1d4ae555fcb78a94f28a25617e860860d659a01b32a45464a09c62e4d3bd32be1e0c0a3c226b681a75e332f31f02a24bcdf0532aee56566c22f36bd466cd64a5d81e84e635b8720f761570e5a322c3bc13f8c3f4a596ceee783063519503c6b6aa176eac24494c442745df5e4fef6d412cbaa48bea7094a3a8205a34668cccd4ebde5bc97c8985ca184dc494b62219a3e56b26ecf7b4211838d769b673d4ac3d247ebd4cbbfea9988d4196a67aec1a1f80e180b185094de1521878c8227c714de6691acc7ca75086312e2466d31c08c31f45226d056ac9ee0092f4a5a7d6471e67d3d3f40896df71ee6243bef5840496dffb3395e12511226df07f626f0c67ba07527bce54a2a45d0a134a83b92fb9334d9d085055f14403fffe9bfcfdff922569dfb3bc1f4c20a3fb81093831056a13d5806adaf4708f6fb99461f31a15181c6ddba293018747464634ff03358e3d0329a706cf5f420bcd93963cf515061c9f47763a371d92ec21092db3caa4e60d333aa4b7cc8784ad4ef9b3a805e4ef7cd4c82190a14fb33830d4e779f3102bbdc851b0e0b34d78c1f05075813cd5b6051338b01f4fb56a4e0fc36f22eeb353807b5ec9d67584e48626e4faa8ba71ee5e4b46f101ee1d43fd9a16c831c9cf6a9f8873eb7a520ded466524e7d97a64ccedcbcc7d4f514f440464a457c6385ba21f681c61eaf36f7582f6e0e24c8a8a04eea6f7412b7a860a425940bace9fa93f2e43d0200cde54ae381c10d60ad2db9da0b6829a2eb85c32ee22367d44a8e4bf293766bbc94a83624118ccdd18aa5e1f471913a34c863d521e26ee62a25d2bf1e4f3c3133be6f79925f6e010dc93d1e016790c75ef61d10d961f9f1576d19eb06cd59c9130070d6c244b11ac8f39e7b92938acc6d2ca8409717926793571466a393902aa54318fa9236f0baf0b03a3ca00fb240f474a9122e6cb9ed4782e4f231c73560731ba352df2692748499b82822ddf54f03f7f02c3440f76c3b8e760c6109d8ea0317f571ef4f0716a268f842780ae017d6cac4a89b507cae55de3135e15c68c45d1e731741cc5e89f47381e15ccc10f9025ee2411db4c8c6f47d674cbb697f3ead0a790e5f6a4d0795cfcfd60aa745e19d4224efd0b3ab9a6dd6cd2cc0b1f51408a96bf4a0943fcc0611e079fbfaf861c732ee68855421aa3b478cab36c37eb165f27dcea3a7c614db8c54b7fd3035f1c705f826809aa705da76ce8b317b11e7ddb0cd3f7b09f95987634fa1272602964c893b1b6795508ca44a3b31774bbe1ee24d4fe290ebfdd900c36bdc1b6f5dcf20b471176b3a75f1c3ab6bb2133b34412549786a1dae2e05cb9123fe1e95619ab072b1eacb4c2f2765118114784cb004b0e70d88607a1cd658365c9b406beb96cc1b67db50831e6a7e77a4ac3033240af28a199a0de1bf42fd0cd18a9b2f8e179614f55497c294cbd431da1474006d54ddff7df9e5e21b9d5a13caef46535657bffefc264aae42fcb3cecf922bec114e53b245dbda82459b5b975910b27704fdc10d4af141f53058759b68ab48b9c62d19de633ea3dfd5045ca62357264e272790aa1f3fa484770599b5dd2d768237535e77ef1b5419f034e033ed47f913b6c1a4100328427a4602f7ed0a797c9df1334a5aa29f07669c7da594226e79e9ca02bce20884cda2293ae278fa90436b4e1a51b82f87ed29f739940edbbb704e27ad93e677ec7ac574a0e221e756417f0b803d2e40800ff1a3d93657d5242504e59a191e1b77224dc860517d34f8032a1cfd820dc60d760a307f500543ebb7d017d019ff408b75c238f015d8f09779972bba5579aa6c940d1fc586a765c51fbbac54d8e4506ec8570ce36ffaeba849b9d1e070422c2710c0b92ee0cc7baa2ceea21b6778f1ac7964a7701eaf04475c1affd4a14da2a35147202e1fd77863f5af10b2c1104729fe3c2c3516a52538182cfde9c55b4351da8a50acbb293b168f55c92468d6a2d29d17b2e6d98892cae07ad9b06ff3b74c5cccad93aa885972193707f24eab205f6688ddc29a433f0e23a6241730d8464bb16e0d61d28e683fbb574f312d30b7d769365375558a4be8ff5c866db52d7aba7b92a01220bc87cbd3fc6982d5d72482afcad8b45736c24b54b7b4991b700670a7f477b3450dad53b4f22ca4756da512921c6a5d1b8c0eab1b5a4f6131758604f79bdd5b0a941c0b8b540bbb8b8ee492fd40cf97135ce5283935a27e72c3b921bc01a503afdc6f0949396e311038126b277a1ecf0dd6cad64dd913f41781fffd1f1e695ad46b3c27b8078219749c7ccc98e4abad0bd74d009bc4e3ad7f62f2e2db94b062c3a96dfccb9b037f423b364f8f44afe734f5a574d37ee6e09cc45494a8ab117a3bc664678697015426703ade371f3527a680bdd2124b8c3498b8d9808fa66f39e0d3c161cea8127327cf18611cf911b320913e16a80ddc266d3559f8bc228bd37e07890bdde4fedb1f286618a79e2d83894bed9e4376f749da1848ce931a1b40448be58bb80959f5e6865df29dd6da6fa12f8ec2ebf06085e8d750f71a7579b2fcc655c3e0fc5983daaca203334389ec59420c70d11794217b9e9f9732aeb01e811be5cb53806aa12d5f9f078d1a2bab72530f26706da821f6b05bdc6945cecd75412e6cf2f0810e810518c888136e602a35d551592f1c90230839fc56511709633080cbfd64c3d8b3948af9f2e0130de74ee62906ac59512e8e1cb81e651e3037b13a880bce37f1c32471a68d81b021992e720ddd5827a939b06825c00d18e6e653cc405acf0677a27dec39f7cb0591ae9fa1f64799ee8a5de95faf8dba9a9f48c0db5330f676de1a4f36b361a297f9f4e549d0914b87d1eebeeee95f0f7729abe967a8f3afd09a1f090f7db2f0c10092da149643782d9301d0ef49f882125f3ea560f2c9ea646b95fb8a0e2acc2616a999cd6f0d8542742189a0db015fe567155d7a2b0c621809ea759c2d9b4e1498272e5d88cf882513048162fbdc31c27d335952de2865c21d657cfaa4407d644e1486bd59623d1dcf32d8b6bbab6bb7af11bcf1d94c0d1413d30072a85d76b7fa37d98862747ed87d00ab1334d965e2e20316c3fb3af3782902d5279d58eef7912fc1b4beb696ef9e65fa6396950fe8df6fb9a5bb6abd19274992bee863573900ba3748c34ca2ede60beb1fe62e25b51de530fa2cb169758fa89d3884d188e2c636d5c83395ea55524b0fdfbf2b95c8cdaf623f8a20518756a31ab67c7cf33c7b5a9c7ea5ae1e2f352c0c30679796211bf877c2638f9f0ef2c78dbdaec4af4650af8c6ed2745492094f5fdb64064b39638664deb54cf15edc6444e205a06cd4b9157297870509203bb291815c7c1d6141675136550870df25be05832cabd4d42fdb072f7c31ba3c6fb186172af3654506d9a2fdf22ee52792d613fba44cd322966f86c5a6b61239e79e9b9883774bd99d52965741d1b7be31f66e7c77c45a198ac978d307dcb825d5817edc32380a593767df26780af61769121f10c21b3f0a81d4d6ffa0099bdccaa12660429725a869aa46264dc70e7c354cae37cbcaa4e2ee848e9d43792e5b8b567d4e175b183588597da9a2e061a3c57a0e39745057149831b265065aaede4cd70417dba425692a2acf1665ec684b8e139504f234cefa9dc1c628588d8f6dfe80bc7111e392d1f6a84a616da7934d77e138a58cdf518da0515fa8794e44c26e38d1dcb2c50e5912143928ed65ea455784dddda867eab6fd971c67f66f2a87573540238a2bfe3a3a6dbacbe1be25ba0279164e7fe5c957aa48c9525bdfdc11b7428479a53c1fa08fc915859966821951285dcfbb6a3356b4a40aac72bcb66e0541f5e884c494a06a36c801cab52faa48add4001c6e8456e5af7319262801fdeca0e0be70b01bafe604a24cf049a91fc66f5e417c4eb57f98021800d0f7bedb3e2b5b0dded2f15131876743d11d0a38aff9ec38c92ea56c00e77e787dcfa9362856401b6e6e1e5d27dedbc6d1f4a24dc67718e75e9e161944eb5ce3401d8a7f123d5c350739fd4393b249a50002fbce0299f3f152f1b27c8f090583d2d23897ae0a67663cf189c270c1f88adf518a149c686ce28c2ead1fa59a733ed5f53f952c8924970a18067c178d69751a6ed4873f2ccaffcb74586ccf4f1c3fe82442415a7d24d80dc54437f23f83797376cfc2310432f4e02c8e669dc0ce8b60a3107b5d2af6fa4f741d9994690a1fe113f9933402e08f7d1187b2ff4163408e67a4ee17a00fe5157944f40abcc06e2d52044fc4319d8d7fcfc1373115a789c3613889f60413be0f431049d1683a2ef91cab2e1c898ec7788cd4961ee49aea701b883025d29cd57f7e9d3bbe8a5d64a2d951b415e149d1121c7308cdbacf146f98a7a3f6da5c43b4cdd7c3f95d1ff45b305b6c3413dcc9f0c1353fd60a3c70f156e0b435cca93c3cd8db195975383e387f47107060fe61aa4d5db2379e245928b50a6cb705de3675b3e871b2d8a938fd1aca9a6f1ee1176a14abb926d46b864435a46caaba46899d6f055b31c474153f263f2b3615864ace9f1735856236af4c96ab149d6371cdf764b4e4665dc352307a4c682049ec13e2db51d80e3efe64bfadfb5a368484b492f5e8cb8768f33c95d3cf3856d6de0bb6b542d5175d1f4accd124db131dd3a8d912f18e077523a6895bddcf47966063ab65da4da74162afcc7d3f8099049010c515bcb46ca1dfaf3a36913c833e2c148e2c86a9adaeafca72b79258cc7e75d9c66fcd38eb502c4a63cef6c05e074667054e1ecee8bd8d81a2ab005205197d46c9a3c22be9399460236a6fca2d72bf28045865a4296111855b20fa54cf1baf3fdd3dd62e35364dae7dd56bcd2b1582875c4704b3d9f6bd2deccc015d8e4c15b2cb394a7073e9c4c8ae27a63436349620d8281df4966bdd25fd25fcb5a9d6d3b69d6cf3e809d7b3f33e74eef985e2e881880265c1ab63d7d2ba524bd0caff7f63e816be364907a628623e52327a76c061dc5ed572ca6ebe0ddfb13fd57c7132a3376e79faee4bff9020acec47ec003b2bea9cfecf093750e5c7baad2b0976fec5718c1e74e0802fc46d72b5280fb02cca72f5a66a9ea7cfba5408f4f67f19d028179419ad57489a3cdc929f785e52cf100b7252472e961ccc1f48f59881827e982f8b1fa8c504b11c5e746b49672e7859f67821827636b53264542eea6f8816677eeb5d90396f77a3f1b17383b09569a61839dc362251fe6c5fc14323d1f1ae463f4e1a78bcb73023cbe62769386e76f8b26d35f26fdb21fcf9f7d583f0ac414cdb531f3076f9d8bc1245497790cbdb124ac5005d84f260c79d764748d67771fe44096727d80064611cafe7f8cf435b1c3045cac1e5dbcf215271e3158f6f034e296cabcebc23c11b61794cdebd34073f391e875e0134b13018a8354b66bf2da0c58d37bad13a6415fbaa04d0331d0ee8ec2052a4eb0b0f033294595cf5c4564c047d6bdb51d0150eaad1d2e901a3baa42f501d477ebc43ba2735a7eb2456692fbb61f3af5b867c748c77e21f7bb9b286d3d62e0507ad9256539dc6d7c3ac76f101ff4f97698e0586d9c17a495acfacececa3e941d07a6a1764b46134a22cade80e5cde6948ab417ed1868d57f44ccccfbcbf54e5506c00e9aa8fc6ba478f42cf7ee512c0d7f968b3b124b89ee7547134352ad5746abbb537c86aaa8e065254638576e3422bad283b484cb491b115b56346c2b78d07d29a7b043505725784d8bcde0a13d2aad597969bf78c341960a84a6b50f017adf5aea1981ae7f65d40fc2c2d7fdd1c04394aa1e0ece7513bdf25c45af07ae2969a922bf03a5f2ef6339c5b160fc","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"6d2400d1bba1d7cf7a262382ad3c3b50"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
