<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #00FF73;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #00FF73;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0E0F1D;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show"
                                title="Show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show",
                templateToggleAltHide = "Hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"022e8a2744257760cfe5cbaf2ee616ca8c7ed438b2b2622469d62cc8a2340ac5192a4e53ae0b9dd43fe806ff05d18f4c01160ff1283271af88d2e92e19552022f46241bb0e92f407fb0c81f17de6dd0c621568f67792ce10e1df2aeaef193c17c7df2a5c4aa48395da6d709555f48bc75595649b31417ffc59a15c3545d4b4f2394905c1d47afa4e0fa3e86cbec33136edd370ab336e236338db8111607fbf3cc4b22f76d903e7ba41c1b2187e09e9a9404ba092f8045e9704281e29208ebdee6431fe0ef2c3e5f6dbbf2fc96be7d347417ee8943ce18a02a1c8e0f68c1a524aab859b55c7e2c6f0cac7d54ae3ab64c0e7d7c3569aea27a7ebb05f25a7bdbd42751b86116ed454048047147728fd422dcc71ec93b0996fb7cae568be3fb62d2bb0a1fd643be4cf7ccea10fbfb7c3c212dc96787d4ffc9748e24f88b1c23dc523d2eeb810b38ffdb7f62ddb7fa9cd08e361ebf2f7596116cc3bcffd76606eefb234f7afcb9c52b3a2b89553ba8f3c152f02e9c1653b66c33b24dea5d6315e4315803b067d45f0fea973425ae4f2eb4b8c21c3a9db051e3b68d815a40be754a504528a145f7fe2e8f27d1e920754195e56c4837cea76c781b748d5db3a9fe3ced708e87a5eea222ea2e193b5bfdc6724c7b56fed1183d623ad18762222e2c9892faa012b4af7e3e96d5dd6b3503ec3ec7d0a1314f4e647afa4f134faafeac2245e2f8216f587c37bf5c3a2c3d032e8b0cd45d2bf12f376de51a2da177d8256e6e2c429fb9a6e8e40b3a9b2d5676b9e7ac4b039be9ad8cb71f32e3b123b62b6b78067f460c0404ffa0a3973d431be088625a5df194abb6482bedfefe4a408d9d3d128e3deef0225845d1feff83926cdd6cffe18c9420b8bd5c3d296692605db3bf64ee8074724ae2552699968fcf43cf06e550f6e9e28981737c78935626b537159dc98a9166498b756dcaa943ce3136f1cbd0e406b855eed720191c843a82e6b5826159dfc6bc65f45522eb5b2c42be79cd7e3262a6bce2495e8a4858b43f2bfc047c00d25babff60e107f4cfa1ca88b784481c6be2a0004f2e86dc157dbb68451b51569065a90eeb7b0eb08ae834dd72bd978c5c19b06b22b1d4a5068829b47cf06a76e0afb2ac105f468e1123bf74af2a2ac59c899e11ab1b066faac4df1f93bc28e45fedf21c280d4d1fedd0adabe8ebf1c54c7b6a0d8b5373580704f49cfa4caa97da4f2434431cf98e750866399d5a05919d6dcfced0748d1dfc0e12e9d59b08733bf766a10daa930ae5c95d4e2c7caa98e1a1a106daa7bd0c7dabd3cccd28c6c08efe99712b880d4425e8d8d5f783e020850cd83a7275cd6178a435c280fc15a519b931d3e70235c8be4595d26ee9dfbcebacd01c38db4b6ccbf1560b926a68e664c9f0d39d1be2127962d899cfaca139486bfff0916cd21c36204eb4073a187003a7847512cdf92b14e6bff8cfbeb72f617cbb25e3bc6ee725e6db058230b5664cd0ca39926e7ba1268ba81c2634ec02773cba7938a134f3f836e648f4779ccf4496028967a6c3621b3a960f8851c5ec45dadc2082faf4387b17ecd66f61dae33e9f4630ccaad29afa64665310c5ec3b5e2cc69d55ff2598b94b4f16edb0b800f24a2cccbd66b1b27b531d8a4ccae174de821774296d1733a2c640797055e688e06470cc652ca09f702e973100a6331e0fde71d754dc2825ed233c4cdde004d8d16b04e80cdd7e6154387c013c6fc607da9bc30eff77c385d1eb4ea7acda742020b60778df5eb44057169a2d61d931650233590f4cc123dc847da5bde6b1985e97d0eb7db8ed36e6cc098677afad5a5e1066f87bc26437af6691407c71590bf5b5ab139f7af4d69a046e568eb629da8fccb23f2f5ff19c796918c5475bdff452cba76e54c0ec8d755067736275465e15ec9bf5b9a4049aed313281c85b350dc206b86689814f11333033c735a18eb275263543eff28107c6ed1fc586a02bf0d2b59400ce287bdc33ae04c586c5482001ab38d9a1f7655db25e6a72a4d53dba9d7a311b32e5ab66f1c8b83c36d85488f200e9563a8db831dfac464f32a4e0fb346e74291e58e82ac4dffc9f357fdde352bb6af6fc48a208f9f37fb8b20bbd5702566d895336ff18bc16d00e7a2044e9116acd34fe0ff9a7ef218d1e5f711f13c4fa66809f7cd58e0e699e7a9b229889e517d21fedff058075eb244693d7e2f5fa6e584ca966bf2be90693857e2508bf0d4d69127938888ec8959e53ff001528945f5df770d65890cc9be1240b572de1978dc212b71c143880ebc0e47f1bb5649a4c4b39cb0d4dd4262b5a1a59bfe04372117d44682030230e79d87c19c70bfe762b649d98e2ea9a117090cc63890ccb591467eeca9284f1c4feb78ab45989fc6f0edfe28e276a100b868d95249a39670282f1ce891f6ca828cbe26ff23e2c801e5aefe66acc10b742f4be3f061e97c22f785de8b7652b31f3fe546180bdf7048654736400a012cfb2de0400870c3c894ac048994b40ad02c7370a0ef8696e603b20a1520b439a3377e8d44ac89a3892ea2e648e0a71726b323ea5c5be4675f0924f022112a7dd0f72f54ba64a27d16db2243f3bbaa1295fbc6886b0cd8d16a323a86a3c295f99adc724ed5a89e5d0bff28e086202e27d95e91b960b7b5aae4ed04c8a1fa6d61ffef5b7cac2ad41718ee99cc70bc7fe2ef74229066651fb185ed11301d1e87382c9491acd8df08b2ef376c13256775e14f89abf10d1a74842e0f7b8668df180a62c1ae80c188688aa6aa658cc8ec56692827a04b239d25fcde839ec145e21903cbf62f2cc6e464098762aa87548ec8cb92361cbc3552858c0677da2581f5ad4c096ebe31df33fdddba09d4fcbefd41f4562adb2dbabdbc6af927b030ca5f775f3c2915a9ebfc5e4f1d06ea8f1e3c911967de6c9f8869cb4c0a83109d78cf513fec171451816381c97640a2df2b5436cbf3ed9fff217b4938d7f6a6e4e37a27a8b15a816e781b5e7fca344e25e851065d9e15079f2b202871346e3932ba06ef923252b08e05bfbcee089b861273ac810dbbf125f167a61ffd36663c4e914274651e2a905726a52d4ebdcbb7fccd65928f56f7343e623f375ffae30311a55c8d39bda31e7d6849bf52708184694c2c89757d236d2c923c53add9759b7dfa9178acd5c6125e7ae270cab72e41f8a346a1e80c76cec1dac4228a4ebe12b8642575fb93ab5e99e00a044146bf9c4db9f2ac129d1a07dd3b77981c5c5904321b84cee385dd5aa14819718758e9b6ddc07be45e3d838cd5965980a280223722d96559f65aa02e7abe8343904801446c42b6dffe56f55002b1bd30bff0e9c80ef256fe7cc1da24abe69c57a4cec81039ed6e59098a7d77a069519dd28723147bb8e443423928d15baea888eaf68765aa2c7a138b8a15b2797dab9080d7753c2a493ab7b7e3029d156ddee764138131f6a7a20fc588b196093b921ced948eb04d3981de0f8605fe7803c8c93d2af889b3372cc29e77c0651a0be1b7f143633429669e589f471cdf5bf1d65225e6f24979964cc80125e7c98bf3c9478ca1b0e70fa5bff45ecead5d7e9afa83b9992be93d295573b3a66c3e53e8cd66627182177fb3c39018b7ec2b20d83aa7572f32f52ce20398c20eb1d72797604bd1c2d999d8f0c7416054a2260d5b5304c2fe1fb24210463ff91c2feb7a0791d3590b79f75aa164af9101b24e97e8750f1a401f74258a0a17986ddd53abb973c3e69fc0dc308887ab6aceaf510a385603fc11c851a0d9a77e0d4aeebdb4bd549387cde9348d43a050e5ac42299b9869df05b32b053c905a7a6b864e174c73e44bef69d30799162c0db6b2e3d13f924c8a410969d66737c0d227b9854ee8092f83f334ec5a905b34f463225d4ddbfdff6f6c928b3ff3855a8e9427b4bcc21e249e80e29d868421569a09b8ed9492fe1f79422a352bbd50381ed8961bc050b3dd6e3da990603013f6684fddd8e9cc7ef86b7bfeb5dd5ebae7d81da67cf3221c845abc2484ad19697fcc754b73a90d9b325b88a09125316416d8de733e8cbbbc5184cd685cc18efa6118ffddd14d794e0901fb877d8c21542857fdb1c84c15a973f22d50d132c5e1fc5aafdb744cdc97a411c42c197dfa3591beb08a2da23b3004889b1c6ac4bd0494200b4b28d4bc299cbdd685bbcb2c1f5d0fb42fa37dd046aa38bfecd01830820acf4ce0a306823bc517b265e91bc6bcf95fa92f96ba092ec6dd2d5240b7cfae19a104695de2c41efa2b69a15938b51053197d8d656bfe223df80ccc8a22e87b99bf053a5f85fe70fad1040f2354277c08608a7e343c4ad7faac5556e1671038ec0b422c1ec38f5f9a3f60decbe9a8d1c290656e035877476b5cda8bd62734e6a5c4c8495b01e50ee473d5bab2d5c581b2ae35619040a64b9cd3be467208d7745cb2620c65447559050cc76a9b95d11e9f0ecef2ae572a4399c1ba0f58146ea439899b0d30d743c177c0c826c6fae50c5205002687ef9d9fc8ec7a91f20588ed5965878529a80d01529306ad38582dd0a7e4fe3bbf16b04777ca2ea87e79e670b5cfeab377887f2425de3af034202bdbe8e89955bfabc42a3cdc66549127951f95410ad2c9cb1341a04392c366c6f17c7a893e7dde35382ee662d08dcf302cceb625e337b5d426a5f79a4985193e3793b94232884ed1098bb962214e5e00e13c95557cfd1382b148977690232b920f5428f9b2f9fe0753b803bc92b7f10353302b2c37865fc199733da8f9fb3b01c5d5302567bcc4bb63b220a1072e879b5648f6f972227a6c72933895a9f12dd1d4527d2359e98cdf2a83f40167df941fece7064ec2b0fe74c83787c00f34248139176ddeba14483d85f9b6b0526f738024468f9593a8f32aab23038b87e54a30907ffb060307ac878bf32600041ccccce650b3efbeb52e603a2bf161a19ec9774889e993bf7ddb6ddea8d4c63413656c545bad79d9f0459a7e9203abcc75c4ab2c7861ed8a710c65ce1e40c5a4fa01a27fd69595e671367fe2f51e469180aafac7fe57e822114cf8f218604f85baf6674f11c4d04fabc37d358b4b931deb5a42be98fc33830fdaed8eb056647d413ec16bd762fc84d2ccd1a6269a719f19638334d5c35bd8e1101a793f521a352d7db4cd04404be3df8dfa506b09c24aae3ed0fbc9319e9f2f0b4c732bbff98916f2709c088cc1ffe7ea037344b2cfa3d3ae16fb4f8a0418296aed7a0fc02c48424b10d0c53fa9e703aa4f8bccb47d5a86ad31b31bb89d910a21a785a83e73110bb4c63cf5a5ec1fcc967eb20ede98a0c3c192e24050a7f3da227bd007200481bec9c529c7e29435adb95ebf408e317d33b387136a771274b3875ae18eb08809ef3631b771bdc57f695791982ea4f3e5f79325f8dc2cb34642ff59af84668669f57b291f347434346b732408a93f62eaa9d8b480e1f722ed98bdba03182e1a1d6c5af6c3a3090acb16635714aa683c4d04d694f2c46fbc805a26f51e8efa6199007808244d5448fd8eaf8dd71cce7c0319f5719e7dbdc6828b409d252a8e886142692a3a7de997be12b12b358064c506125ba7c19456f24fb6ac96b81d87036d2feeb93801871888741df586e6d570224e35eb233fb823e6febd406c7ae85280fe11be3511a8a8c3c5e50214d4658f70be2db90187898941e7e31fa2c3254ec571fce44aa5d8c0ac8e8c115cf4160e7f4a596b73f4a249eaec42e3dd0eebb2feb1a5556f819515b0bb641246f75c8c1b25ae92cf7755288324e7035251a16710bfb934c0e5cba6b6949a90d9272e6d9d1996b96ade3cd2c0907e5c9514a675d320b298f87a4018bb4bebc0a612bea401afeec66ad3a6289ba1fb17bf399af9ef960416830958db3bc9ba56bbd1e121860dd3f2358ab97ec3ed90c43186360cecb25a112214284548c5c1f2e86db2d8f7847a6d465e83b5c49dda7e751a0a8f7942eebd81b2a75580c3506966b211cc2f3b5fce611bcaae7c33005ec0ff3ec6a1a52a651a6469a78696f9585a7de1aa86f13760ef52e3247de2ab24d37332994ade37ed4d56edd4e1a101ee2483ddca727692e290a406156440d7f1c324131b8a409b976130b5b93dd98f402526a1fc81685841df10ff90ba054afdc886b98f9482bbbf833f774fd8f8d262999a5387e9593df38e3ee1dc62c51b43b6229dbbf552f558dcf05f8a98970772c682174b6117fbcab112078c28bf3812eac280801e26e3d5438122538e04e1afde59747f2099bc4c03c5c2492f8fd781c6fa890367c96af342ada1cc9c9b8061033be339413d8f5b155237aeff298ce6d5f402caeb00fbbe54a141c20530b7724607b531921ae77e1c87f9bf37025c003c62b1285763668e538f2a488d912641a923744556f017f2572840883da8c404f317c07c57abb6b64f7495400ec82dab8bf3cf79834b1ab22a0d775a02eebcff729f2534a42d5588e836a934cee4430947c47d7042f91cdab01eb684bb225f5a265b7a1789207412acf8741259081c71c3678397c727aece29da698af87b6556d48fb5a3b4627612ca25f76199dcce3685d9e87fde14f066ef328e3dc513efea84434e3f251f2191ee73720adc7ecb81bac1fced3731b3c250fc326a13f59b51b8e118d146ea19bdd42a7ddfffcc8ab52fd2296e1bc0e95f8d8062213ad5c4967511549f4ea1a5bd347072ca3c439e48f913fc97dc9368806bc57bbf6c41636829fd4872b58188b16f03c6d065352fa1e26f87042eeab77b7ab02e080a62740c716c8b807fc0e1996781e31ebd96ac88761af6e8b66cf231dc179cc45273769097df4bac1deac3d40d150ffe5a7b7187fc68ebf4c9b7c2a75b5bf4b2026c5f4f0d57e97ad5ec7d9bc6d061317ef6faf0eabbe802aec2029cf0caa6f34cf3bb7bbb58c5fda3c69f1b19e15713d00582cffc5b447cb29f1eb83c6883c7673b4ca2b162148fc00571ce2abcf95148e0166757aeb0e24ffddc04b2b18181d9ba8e8f33403b471e69502b71497ef4d16f8dc0265e4d2440e9a49a9b8797310a93fbf35a52b483812f77c76da5b4adb153983b039368f3470d549a068435b70b272cbdbcfb49ec71c9c6d9e080b193ddd054f351744d9d43b0dc2b30434bd0d388d616e9e254aa7fd4270eb595d008912fc8bb232285a57542c73b6c1a73b5f93b7186c2fb5c05a2256ed2f0fafaa117d82605a3dd86be013f0beae39915b4b45f1dd0fb96b8272e625f073fa8265692fbde7c7f578d07f2cf35ed917ef1c1457fc8120498f4d6e36fc7057e64f0c1ae751375dad362933b871c5364b37cb73173dc3378daa9dd1a86c7026e7ef44da2e5e22d5e2f7845b30250ef17c98f3ae8cf5dbf93d7f532b16b662855e85c03d4b1051da14d759c0838614e6f61968d4851765ae182ee24996a9076b098a2f865445227174f247f49daf9f8366384f052358794e6045c2233a61c4b7566cfbd8be1ed8772b30fc0e5e450e1ce79ff2d48e9ccc5aab393172f169154722d0673655f2d709c5c5c6736f95d2a9ba180f358e6e890ecf8a61dfe85e6ca2455da6fc17cf9d1a746e8d67038ccbeca4b6f62c9ff46837fe0fa8e6960ff5e072d73fe31a5240636b56a83e48a53896f3e93498cbe886e3bfbb2f7c11f5f0b4a99fea4aff208a90df09da906508ab82434a5e11931e5059b997bec89515a320ff93091adc7d08dec2b72bb4c889c2f473c2703aebd2729f3cebc0ed68639906522a794afc7c480490f1658bdb8ef15fc1996d0523c732f0d8493f9effda842ba34d3eae2daf9f444c9ef39f5ea9ddb6e868fc7d6d117c2d254d93c78ca5d877afca63ace3566b0d00f43ff99e1936f63794349b4986a06e4db329c3420f1b87101a040446f79a4114b82eeb7a4c2a5449e1b828f81071844e6da284318bb319b4c88855731f1e65f1feb235e760ec72aaa5a766dcfccd353265e990569e513c12c4ba0de67de5e083c0977f3243f69913d70e9a371f3850e7e68ce1b4c300c4e8e5e72ced668d6056feb192e2cca25e48ec3b0609e82a0ddf8a243f1b341501d302fde7cc066b7ae56ec959fd963f9a971a82592bd7d96cee98e0f85ec38b296aba9944a84c71e561143592e005255ce1021a9619e9fba978abe17646c1cd998c3705e5a2f4744e212c65bc19e808a12a9ca387327a6ecc047eb11bef60dc944cd9bc5cb0cc6323d795a4be4c1ce2f109bbc6076397a8e91656c9395cdf847651a4f093646cea8a76fd5b521e6db59a4b33da25eab30b8cf4069f4dff09df2319b815553af62707dde962fe985f9549b2408807d461fb79889f44147454c621fcc0981203dc6a808708221230ec9994802a4ced9d0dc552643ef55a55ec523f4376d4bf0de17420f422c481a3cc788eca3afaa8b488b9bdc528c2ce9bab8139f4c1ed95457cd11e6e2f16f5e17152b51e4316ff1b6055f760964329933726c50c33a8bdab241b053321c8a1d4cbbf549895105247eb615d97f45487e4f6fe69f3dfd962b642cbc037001cda90ff7429f7a385a263ef0bbdde6c3330f4b1569085d9cb9a5b5f96133cc339dff9ba8ac23b7df0ce4545f58e1077121c64dced81d8eb4d8a5ca6e865c096ad2955938665630e6c07b890edf4b4cf0823a8fcdf05e742dbba0439b52b6e88ba542495ccb7731017d35ad33bebd5be513e66fa543c3e75a5540e1c0650c324d242a491fdf5b756bb941aa45f992a2f365871f94f492292b399345c8901ebe1eb67a45382160feb5a0c1caf5aefe5393dc5c1bcab802495e381c730e60b2ec050ace32b7fb85c2556f6cf2a89d702273908a545627ac1c2e0b15237fe77241516a359bae4bb48de825a85ed5d1d9034abf027a8fbeb95ba4b3f4c751ef2fdd4b323b4e16f0a52c8a8a726fbc020495164bb7ab444892c0bc1651f8d9a969b1573a5b83a0ae71751975b55e5f379acf40136973441e24fcbe154e2db1aad80380eaddf8aebbeaf84485149cb5e3976f4b042abc674919efbfa45cd7d9b4f1cc9854ecfc1599a108e8695b9ef18e354978f2d750643f9a9cc26646119e5acb3b699f9d6cfd890ab62a3c26d621d40e7cf77ae65a05c9a7201ca3bcccb4c43bfd7a95899327e38d2d305a115abb20a274a47023e8912b92ba9089c821c932c48318f182896739acee0e8ad4aa898d5671d04d20eee687eedd86a0043aa362e60ffa79cc101ee6b3e5bcf23e6bb7ff25abff46190dee2915ae703c2bd2d4bb2b3301af900306c0051b7353249da44cd413027ce7b30adc5e9c1c65d56a9faf92f2c94fed55f8265f05f4bed4e07c69de0cbc8845a8816bba5948506fb05cdd3df52e523d2f12145cd9cb0dadc730b5de6eb9c87d5f596a9fd41f6863a9386f21b08e9ef89ed97078deb78efebba31adda65a1571e7c3dfde3753b02511adff302de895fa18781feb9239f01c38da9e56a682d734188a40e664ab4a3abf88d27e1d82034d037700669bb699e2ca2263cc3bbb3879ab59d55a189b2e6b1b42ae43fda63ae64e15353c6de0aa46eb405f8733d88532a390ef4009d4d6d718832ce7cf604250f333bf3d05d6f5d8b9a786cf71e347b721483ca0452949d17e04810aec4940e20a3e830bcbf6eb846cb471b05ff5e9901d4892ab3313e7f1d594ae36b5c1dee13fb8865b64bc14082a22cdc74a2188f848558542c6dd93c9722651b9e168e10cea393b6eee73a5d1500f04e2bb9591997f4d27114433a36c4f519fb23b99f32e444d298e79e29a9cddf47693a9bdb4c87c4ca21226ea8579c119850e56c81384bdfc1b38d1b0d41641c683322fc966229b96088b69f56cf159416e3fe92b223391aada3324788dd70c478eee59cff25fe78e7af547312ad69db37dffdb0b92944150000a97176f9d13856d1a859523058f3a7fed047d6101f3320d0d9ad43021cef761b712ea44d6170cd3fdc526dc44bb28a8274c20c5210860c7fc07d5f7d7022737ba1ae565c4b718296614e7328af14241b76c06cc63d37d5039a240d372cbd5be9ee828d78626d49fa0d914f9eb8fb3ec2c12349be8f5baeafa7b4552045e0a4f7f948b287f107ea5be58926b50a3a3290980377c76dece43274f84f145bf5c24735d008dbd49c1c1c3d1c4afcf67fde9e0c7c09221e12c201363983407818ac2db561bc7bf5e4e6a877db047ed6c174e9b105b7410a86898423e46326ad243f7b6a0e5a3461ff0b26440923607274324117942016dee6dd6edd459575b290957ba410808ae7dabdf205bf3fa7647ce1e262e76f650b0f667221fd520a0bfff72556c3c912b275d7e759322dbb1ef0b0bb96d73e55f7fa3ed1fb79112ddbea733c6a8645cc8f75e8c8f50158693ed7ef20fee221c38da618310bf30301d90f3dcc2764a1aa43bebc1257e43de09dd051d9d37dc49fe271128aa62ca987845d5e415082925450be8e8911398d12aabf1dc98775c6b64db950405818bc878fc14b949a91ffad3c8331387d1e890d56c970177e652249e6648900ae8606ec2832f7711c7234283b3263434bb745230f42bf1531754ca4078f7f2165f7271b70652f668af290104c87f368c5adb510b3679293d2d533541bf52e3a88e64516e870b5d9b6fa85b86878d894e6b21144c5009a4e36d5be059f2214424159cca2f65dddeb88c1f88d7f7011dbe798484bac773b8f7f6dd11f43cd32d0f84bfc7d88ceff5105be38ad8b2b71bff91ab5d9acda7b370242ef2b137271552a6ce40c11960919bcd0d4ef8a6e4f0c2b910d7dacdb3cabc5098112811911022b10d8b361b4518446da20b4c9ffad3be64fea22f6c8bb7a5e327c82a1805f3ed165b58540c639d6e73170a1b32502e8a8a2565caf574ca77f7f600e4c647e5122bb422c7db445efabf88d2ab63a149b59be42089f8790ea6e08214e39059e46770763b74525760ae8f4dbfb2b4e8ae133a4f255711fe8d6b28b73c6c24ecffe49e95a3c414d3b16bd9ebe03566aac3752568e07c027b55f204e08e01689d2903477f02b13da6e3b40bb00f18a855435247f850049d9e95adffe7c43c904e260c96588ede3ea623dfbf401a3b4c02303fdd4cbd1b17a4dc9557b467d77587bc193acbd2f3a375c201dde3e18c5a8f9076cf189a5ece7f0f6d2bede6192ef83f8a62f32e8a195b376ad31a19c82acdc53080e6bd12dd65d974da9442ba45f0b8790df742c451583fa78b44a2f10426cc67ac105362d46ec93a76a6a5a45627f4f1b61d46d8b10f494064f63080b784249edcc7b755df2fbdb678a2baab336fe5afd9a9d6f28b16ea96388ba5c591d06a9499702b7b19c9e19d1f68856bb6ad35c3f3ac897794a8f97f0f02f44a5b32e05839d4f3de0f798f8e597ee510f9a6d8212658d519d74b3d0b461841d2583f2af4f1bb2fdddb3f1c9e397358ebfe8f33b3d5800dfe68a3e9fd4f98ce4a074122d81a15421b5263bd254054439b327875573cea3870737bcf6cd78f41c23a5d6ad5b888528b10c3b14ccd365d45b6fbe171c98475681b0bb17a2995952eef318a11f858312baed55ef72c6313191f56abb72180d6a3a681218932b3bbb272091cd3d1a2c5692846dd6c138fc79e377f644dc24e1a6e5555834361ce890c7c270962680eb4bfb8dc4dca1a0c5b20ecec6e08a1d8276b8a20f9905e193ed6a901f62501704c765e99532919e527dcac92ac75c792827b3e33a28d62a454335bf588bc27bc146e113c58ab0dfc91009fe5527ae3a74372","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"6d2400d1bba1d7cf7a262382ad3c3b50"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
