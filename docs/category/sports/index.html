<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #00FF73;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #00FF73;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0E0F1D;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show"
                                title="Show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show",
                templateToggleAltHide = "Hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c29c69e43a91ae41d6e47dd98967f8dc360b50028fc4a126307f93ff18b657e4813016e8b6521a27973459b10d7b1bb4afba1ad460c8921b6cdfb73a9bc8f7884eb36641f38b00ee1a624c0f6ab08ccd076d8b56defcd497b0f45ee51ef3adf368f69d473892baa77ffcd91408ab755efc2123003fe1a9139f544e47ed53c4c9e664df98883f4a5fac13fa4961777edcd2c5c7b907a1359a19aa74eaf252c8317ee55bdb5c699ca2f785a14b0c400e2f609acb5f067bf1378ee0ebf501e7ec398578bc9f7656d12917071b90f55428d8ead6745395e46fa69e3f78a9d58290f662923e7fc06300d8d94ef57fadb7846da1ba7e38a769fb58c7456410743679a199bf713c7e7b954210661983dbd443ccab791c0ca7d27d582691cb844c7d4ecb29ce2997138d3e8116e043ce66c1f74b6111fe60299154005cb81a9507422d98e33f08748311ef103ac877eb988bfb2c39e47d871e56ba2948a7ae9c0dce394407a0b4aed968bd863df7537e64d62bc6d1710bbc3d8b3fb604b030ff7cec99601dca13622fd56660dae9d80a7b625911fc0f7bfcbc5e73af228089ff0dd011c1f36a71fcbd08b09fe470c4680685351e7d5c6ba06ce52c342ed16bc623ed5c90cf876f829c7084bebd275cbfaff4d03563736e1801dfa1c40bf732e0844afe8a0689ec5333ebf38a6463690fc9585ef69ac9b83ffba84d7d7009abdd45fc81c82b67f49a7ea5dc8a34e4ef1e7ae1694cd903760741be399fd3e809d77f0ad81aed08e2edf988dec79854e7274d19d9325e3e4dd142dc198276824c77c9621b2faa479423baff0b91ccafbe5ff3e052cc82ccb7cb69b1c74847831f15fb1a48bb54db086942c91f13f6df3cd9482b14a218099ff5b8cde4acb66617fa67405262f6a40778bf22eacf8ba7d468a89fed116eb4416071b39e32cadee4d9491c9fcd7c96ba5bb7d90e0c870333edf63779765b6b3c8a2c7e2b1bd072d52b1ada12cf6b867395cb8b8288456628780640e41a9877b4047fe1d8d41963890ed054a229754088efc2d226e44a54ec9adcbd747183cdd22a58945f62cc466d52d1ecf51226b144af53126d190f570654281eb3aa5db99744c091bf9dc9a21dab55e23838b31117164d1e294b5598fb338cf0898ec09ed183ea7b82a1b18b5c3b65e787c303848b0daa609bed7b803e204bd9c6915a712f99ce40fe89131b5e1017b938f395bc7490b5f3bf475a53b697200df9cdc0657712256e5ed429534bcf85f249b5a7b08f1ec8a5e66b51dfc0b7593cf74d5047cafbaf591e33fa4aa2319b403761d159d24609cf671cda6caad768c30fab57a6eaef4eb56ad8b625fd5e18be6f6c06bfd593f91eee28475d2aac4786f84b57d69a0bcb90b6bd497d556ef8a328c7930985300a4704e6d269c18b4ee9fcfec9b1eb49c2803376378333820085825a97b3b7b1bf6446391ff79b41fab09bac74168491e10fff099426d9dd59d69c1f9b7fe4e1d1f64d819554c70eb9587250855e0f3bb926b6b049022babf5e034f5468959e0dac9de3ab9095c8af1f615ee2b5620e730beb851acb897a536d4c77a6cd08eec77191339660d3a68aa6590f1bd9a01ace67014a59e4ee5722e034db929eace2ff62aaec372f6a94c92df5e5ea68a36ab625d91b79ade17b219d53ad4db65866d3a5493cca49a96f9b5171ea34b52ac9b342ab49cdf62595a162a7534e0131683ca2393469f1724b14f83e46b54d441de75ebe2a7317b3a8bb17c4b94cfae4580e2cbc03e329b62dbf40c7678806d19129c87a8ac590b730e655c0fc663088cc65997d263141d5ab85a8472b430aa6930b6fcf04f72093a2dbe47034285f40ed28ee37b715e42e9946e85defa5be55704a968179c09bf23e0420623b87e7bd234b9ea4b1f3c65dc7a33c64d28d3b753e1c8d371859384991661d14a365770416627211c3fce50a228716e6527eaf53cdc9b2a0297b492e9682e548cc2eb3c83a633f6287bdfcd27c7c74bcab21a4376abd27a9b682bcab6214e5a4c7d44c312b983319c1da05fa7eea6889d8b0c10cf2dd0cccb18d6a3a7af769b898eb6715f85e0619192bb74a63f3aa12e935b224a57785173c9be591a96d301c3867129f016f171bc0ebf076dde28eddb09c84f5d153cc890c1df57fb904ef92a98de2788db0641f594beb96e4d0f6a530406d16b92a640740b4cdbfd04891e55a729c22f1a8179a345cbf9914ddef7e1f300ec8776fefa51c2a513ce2968a06ecdb24592b8fd554dc3358e61bff199d8f28c5c40f15ed0cd7c0acffd9ce8737c7a5d962f3f0c74728f947112736a0dcf5f4ea129dd5b588e27280a7361c6673b7327fa85ef5c39fc8ff0cc3da5e33d2416402f19ac353829af0118f16ff491303255602d6da88c70aab0d6721572a9036885607094404bf50c61845cd0ce6d81b1507113c299b0502e39476438dd99fabc970ff061bf8456587ed1dc776676afb6bfea4980b3ae4447f770d96596e147d3c6b0de933b4d585a5b36c632ff3dee4cbe863e75085fd2f5e54cef017fad81101d5480e118931edd2cb76cab9607c347e9d761c214baf918529ff60b5e4c635454d88837cc9484c673d0e5138c6e9ca60c1a79cd291ef0cde75fa840b91596460de5a0f235c68aa66d6407d71dfa7c6a721f68fb17ae3ff5545d5671e72c1fe0d8b3af207600e2d10805962203758150785e344f831342a6164ef211c88d89ec8dddb4079f63fe2c01edd78ba10acf03b75b751f08763b8a54d7ac214b4c8b4a5aae414b2d0efdd987d710e508b6b4bbfd986d9fda94cb6bbdd397b592bd239d724e4c159e3bf3f9d0d442b44501743ba459703cc2797499285bba8533298f3cf800216d45e4c0ffa3baaaa8b6afc6860e057d230aa92f2b61a6cf35624070160b21fbe648bc35724424c9836b59f7865563a6044fc5f6e639ba6e8c4eb89f5674d5cde440428d1a459b363c6162804be18d34f96cb37e40e16fbf3f79f097faae20b74402b1b3f13a4587c7096ebe37ebdae38ad24ff12cbd622807704a9a5efbda371a110ce4bfd819ef87f5b1112699339385653bc287bcd02672a8230e6b01308d0a077b07eaf450790ed4a4764c5f8b265b543defb5be2600ebe166d438a82297a4f902360512ef04f0bca8ddb7592f4ee802e010674ca1e02ba41a1abcffc707a077e2ce384f5036ee32c318c55ad663ce9dde3fa0669c613342d4d06993cf163f19c7b52ca8bf72ebc5a08f89a5759c2f8e9379f48399ea86e174999252298541fd4c8caad48028caf033eccdd00249429c3a1da0e1a7befd56a6b50d3ef2d5baa1990f093139d1e7561545e389b238a26fba69dab167eedf4f43433b708dc66224d23e64d3273df8ec75c754d75d1163dd9a9bd43ec69b24a4afadb5614e9b4a877325ffa14eb68edb3025ff7969d2ef364a21558e4e4fc692b8d8d733fb925947e699f52ec9f274501773c9cb497e1daa1e087673f9e81b76fcc5e8682fc840a27d424f0adeff0edff3dbb973152d35853501f3a79e2a499fdb053dde9ed97cfba0a93aa7d0f98d8a5915be386672ffd5b472ae982c52f1918da5aa4db839ee16594e0a2394788efbdab65c3a395e522f46f1500c2ee110b3005bc4c0a928f376ab42b9bb0c9d50a2522c83666ac384cbe49d57af932764566c90f49ebedaf80901821e66b6bbf9fcd96d66ff7bd963eca33cfeb8be621a8f678be4b020b4470305bc3ab434368e58b1a8410baa62aea466df1ed5f50d41de2ee53b2484a365a391fae8e41447f5cdb7f140da01adfafd39668c67e22fb2ad7ab2bd76cbaefebaf057b50ad9bc126ca766010f07af6f077dea1f8e85228c62673e5b6d28ade7e0464b6748b91a398b762198ccbe10b9c2697071b05dc496678b4d15a0d786567945f7c5c91566b80221f554225378b3a86e201e044cb795707308211180182a3edfb6fb20f3c41e24c2ccedeb5680cef0224060ef5944fe34f6e0169fdddaa2fcc17497650009f1c3e0c5b67a46b428528443ed4279e021c16bc1ed589fd681aa58407e6d817fe0c280daccc5b0a4693e437c9cabf2bb60fa48f379b7c9fce720b7f96173e4653cdae005e975ab9be462a4ebd160fb752b823e807da20aa85ba36690d762c7ff91fd1859ad4a4b2e92ecf2259ea3b5656d74e4539030cb4fe0328348cc7f1892519b51e353b8a0df2cb1553708393704b1c330ef48af57e7ea10f1f6fa61d417d03ca47bb7e93e2d5d9e0ab89449aab94bdc313608541f475a38de2066dfc5b5f8a8cb12ec3287fad45bc0de6d3d08a2101deef89caad571e93ce0003e945e46522d9fe292757501cafe60f7af54588adf52c9c710b53cc4667f042936941e01c8034b359603043f3385d75b43048b943e40f7f9aae5e89a55c2e077e6cec699295a32e7f73d808ba52a4e39c36b680858e63ae352f71115b073fff1814d4f89c65934ef336e83d5a2b654b6e1180c446081fe187a287e2423af8fcb82fd76bae63a768ffe58fd01dde94a3961a14089309409b1dc25c10c4d73dbee0fd3798ece5cbfca97b620311828fb8e68ca2e17de2ee61dbca6f68feefb517fe19849ff22d51e5d04c32a497d077e845c6863caf6e87fa56e1cf29891e1016510d452eed3e03d569d782e686f3f10beed5f5fb93053dc4761ba6deef687041ada0c03d4ea2852c6b51dbe9932452175438d14d5db79219c6f1ca66c404fec497b533588025501b294f1a8a6c23c5d58cfe1e3f07e213cc622981db3bb03d9818e69f97616367398026a3490c276e161e6ea998dcdbb30bcd8c52410338fb37a8cf135972784c229ad4f55690cc9277233f43b824a9f5774f214345a2cf54d483e82cd7b6a3d8de9c59b92cfc9afd48cc673519dacfe7af92d49cf7da399509666c28d36c3db723b05432411a3e7bca266b3a5d7ba02342d84710492e43ebfa33595353b046b9f043bd0e7c911fd0557407778e5822f76c3e44ce1ec3e211ae223d486977696fa2cd284a63f66355f782e0531268c248cd00145212b66a7b8474c15da956bb07e49ae186c2d12dfdfde5316462d69a378ddfe06635539c7ad11a46ec4e949f9ccfb371b21f3287b0aefca324c2335eef5b0d46213c16f893aca8dce683f539e8078417d35bf382522f1aa86f5ae713f4aa85797579b9a8969893f1e6844d09858bff44a451b946af89b983fe8e942c746480e92af972437bfb3907f8d30c1d5c63d7cfbd9d03ed59e8ba5c5e621acdfbbc087faee6b84d9aabfaa4fc285eb8d643e3c1df0dc120d3c63a6831ff3a1d75a8cb517b6fc62c350436ad867c00de87cc668313dd32bacb965a9500a8c8077ffcc21976c9e493c0dc6fb5b59f91ca900b787af3843c76e48023811390ebba2c0ade727d4deeec0a380b0df2ecdf23a824d4527548a32ec4c12b1744f86be6c520f12c36f25ac247fae698bcd4d9ea8ee3a1afa3a43da92a370783b06bae27f957558bc1cbe35ed9f9849d6fb1be779b76dbe570fc1497a19dbb75914b811ea7029975220e565f3a4c71c2ce26fdbedc13b877c289810675b56318e2d3667bfe157c359c7d97f1838a604aaa4c9b3d3f80c2d60901e2fb8592c53cac444ba3e02ba7fd6378cb2cfa95273ba8be1a8079172f862f30a18308cb7df031275c1a0d2e5c90a887c6b99eb8b2027ec3c93b6a0fd5a3ef8daaf1fc45e5321c74e9f353fab33cd8a549cdf63e3b32911252ac2cb004b1b446696403633696887e75011cdc50a781844574719df9bc6a21c8514e120cad38b8100a7c093235932624e575d093e3a247d4e6d92fc0dd3709e3ff2b8c0fb60e1068a7f72cafb72df55a00b92421e43a2a224e1f6c28dcf760dc4ead42a4c0931c8fe1cbcc5c5191663369707626e37ef5d6bf7d6469593f57eaca47d3cf1d0664acd853cc5958b39e6d7ed72c1681b2e9fb2d4a64159c10b8a7a28ff8587a89c8fa8bb953ef008454b37545afd1adbb8f203a38643c95be847e3c42cb8f8373d18ec184ea40199a920538efc988f7ed6f92f16e2b1a0fdc98dc820a0fd33c5ed540afd59b973b2c411e59d4bd4b6c28f88e0e4a821b2ca4c9b6b559c2f6ebdbd04931c3ed5a8553f98eb8b6122fbd10bbeb7f9afd39bb2d7f9a1f7146ae94c40c4b9263ee7d3833a4c973ad65aa6ce2618a7459cf38e268a45266693ad1d08aba9b3c23e5557f791237b83f4766143f0513e358459ea351e02b88baa8f51eb890a40ab15e811017e410e0cf2a1faef463402619a8f232845903d857950132025ecfdf796b60f7747ed9690434ffc126be93754fd96aa6ba2e0294cb6f178673d77696874599e8e7bf43fc7cd1e96ae8128b4043aa13c988cc74d93a3bf4c0853926e12260b205e51cddb3db7afa4aa3384868119b33eead6ae3fa942886aede45779e07550c5626ffcf3c083ba51e405f942816663fbf4048c28e906a3e0030bd909311d2a639627f3d699a85717cec573835cc923573506ec72b1b59afa81226fbe24fdf4e64b2cb12cfa4b6649ddc6d08b602d48c452e2eae5eae9911208b25eaab5bf264dd09591376c7bd2ae551a50bf809591de4fb07770537da26d82d20d11797d01e0e34ed4a0eff67c73352ab4dd8a6045d59e77519965ed3a878bfb71849ff361b491428de920bd50939548d7a6be03945d07030ea95d460cfbb677c1b0aaab57a6200c6e721c410cd1b1ee5e04a2519b2833b9ff3e274386c4824c5e400094e0929543d497f454053094854aa4eee1864c7f6756ecfd90743f1d0baf1b2988f54535c7eeb6cfc15c8a0749c4418110916161e8ea1b92610f6e5f37c1ef8832429b557dabc9b1a08740205f1656853fa2bd28c8349d11d1fbb11764aa363fb951378199f9e36eee576da95549b8da863ee9f67371f67268697eb1dd7f0dec1682d605594987502e9f09a007788acfa5a6fda38c0d3a1d66c7db72e107ad952314d99ff9646769af0299b261761052f16fdaf86dcce58b0eb1d82b8d453c696a1fcb25fd70b8965c97c95319af994a1267076d1494aba669886291a814317752f39a83390835aa0ec9a4bfdd72608e9b9eb22a54f6fe5795290e72b4197f2e8868d77046472a8ed9d0f111ec247a07af94353c3a50e0f1daa3e38de739fc4c72e626d660ba849183823fed3d8a2482271111dea61ca4b1e940bb485f6dd147857dd944cdba3dd0c8277ff0a155ee58f6061aa1e5128831fb806d2b30e468532b7d98a37cdf6cc6f5d413c46d43bd7a6d54a5a36539fa64c15b20bc7423099f6bc623a4333815e82231eb4f8c43809eba83485ebff5edaac1ecef39594c2498d545a7316d44c2703a7b5cf24f4debd598c3166bad94d3c939b3e7c076ccdbb28c604adb2f3f872e2ff1e076a57d5ff0b4bec0d2e21a61e326025abfc8a65d94228f8946660ec152e0f9feb974774dd595e4c012d765117b866a676fa3698dec6488869b591929e2d9dabaa1d19dda7063dc657fb222cd9e899aef47bf2bd328787ca860535ea4e99b3a86392d84470b088f98d909fe9fcc812a0b4ca6de41bafc294c22e89d1645e31b5ea56b5d4c80efa33a0eda6267d924f665de8c2fad04c72fb8f7a9247d0a48316e17438d3ac2309a452b457448cc24c1f173ddb9bf1f52673c09a40a902fec60aa4b899e5ab72f3380abda35eaf7484351a282df3778e46c049cb721e9c1640c9093a682553e53dd0bd6208cad7a8aa77d17abcad0231708f04d489bb19ca509e3656f3dc27fa6ff70293cc2b5da3f7971bc41da0a794a7dc4ed277ac408070c835b2e423d278d8e3da9f1a1ed1f101ab53fca8d635df58e70f789e37bb079e58feec3465f0b6a6e2cc370dd47620212464e6db4c484452d7d8608028d005d05098383bd79d656efbf6a22af169558a2f4ac0883cb01f2e15f4489afbc375ff32682724c218bac24960ef9c0806a4042a7ad27c26d06da3791d64c76d54827f49d1e8acc776adc5ff32d96ba52634f2d6ee3d1022d39a04456d0ed2d7898b9b63908e17f2fe8e8a281f5808ae27e16dce4226249d1d98c033f7b18fb67e407d745b700d4f3851d1958720fa892df67396b7e715871f56fca0883a4e6aab344f0fac56be31c0622832ffbc7aa3d5f219863222d2fd838f4dc0968936a4dde303e0114e7dfc4372ec7c4d5ab5796e5eab09f6f529321ca97da1d8b3def607b69db2d8e19e943be26fa13f4717c801be55dcfe6739df94a7687267ae42c8c0f665aadbc9507b89e8878e062d33b0373e6f4cd4c9bdcd06d19d3ace047c52e1418802614eea4eec6ce7c467ab0742d48cc7245e2400d101443948bb2485ed8d0819ea04b4fc19abc9c7bce9e6ce20b69dbba1fb69618dbfb8feb09fb629f44e591100e946ef90503f2162536c0eee18304b02e53d2f77e17c9da8bdd3b1324e3640a40f0618a338d0495a2b2e359efcd40df7faeb392fc70892947e2bd55bdf97f756f974936c894c588947cfb03cb8788affa0f4da911e375b60dfcfbfb77fa0c6be0199fbc3c8dd5f611150e27194a5a9f2b9e07dc0795a333ef39b784e1ae7be105d8b0250bc7284dd207a01019b09c4205e25d5c41ffd2eaeb53d07e8d1e80f195ed8530ba37b8d9db0cf8521b7f5927bc3eba48db63baa99f0bd5be178e8cc4b40b8cf7e69f0317cfdc10036b9a3eaf2466f6559a11a746295677e9e26410d5479808ac13be1cc7d1dd2c7c587884ec26544c30f2f15439a855f9eed4f9359a4bf6329d214371ec2fee580ce3823c9650a94f1ee920db018ff6a6ea9f3971ce70b60485ae94ffea228dd834396aee34f1d0add77891f153b0da769f72e956891c2d3a59a473e2daa19f195e55bb426204b82467b977edca6b549c44c0461c6ff435f1d5e7ad55e351f282ce95d96524fbc24d3245b7886b699580f76bdb6eae7756f2bae7013c92bd79c6b98bc445bebeb97dc530b4a7682e510e5f437b9525890bc317abdc1670e048ce284028e838517e6a18e73fb918422996a313c4bea5670e408c2e172fc6ef139b9be8135b1daa23ac68eaa96e94cea5aad7af8c4153c3367a71f5a649b1a44bdcab062aba819b857cc99d363e46fd7870281dcbf4159245900ea448bf497ebafa2c465fcb7b6d1697ac45191fc53529bbd0d2c19b3b986f97c94c62f95a183e0d01a47c7bbe1a4075cf7341297d6f210685c38dcacd5e49d1c87278341accfa888b8afed27768cc2d6c089f51eb977d52b29162c599d3c45a21b9ff5f80b62c6722e2aeb38d62c53c561b76eccafedd8bad737b62d44db687ffbc4f508afd5828a11231de44ae30d1ed235bffe01969688b176bc6df6efd8e8ec5a0d3134b1455546b1afcf73d584a95e5c4c8a0932869ee5747cf80ee6c0e8d61501bf11f89f6aa91a07d04087db01d3c37bbca7ee23f44781c1fb18e5053c87bbe56b3c3b79e1d3ffc9ab5ca4ec3384db8eb6cb5f32238e9591cb7278594e0c751858da0bd186293538b4b5bf9e4da94796b6650374a30bb07feeded0386677d5d29eb2aba795c1e4740cf182ce50bc83d7b9dba72a49af01ad855c692a110c1ec4f1fbafd12683cf3c6dde401ebe1f6be82dd2891476847ddc34c1f0b0bd71f9d9aca3711f9341690028a5370c97503f0a62eedd7bfe99e579f16e8721e032e8131fac7e74000ca45b7b27267dd36ebddd0ab2dd5380316bde62a9c9cb2a3ddf9e0b6b59fe77ee67c7545794e6999b93a5a54960b90ff4d512258042c09e50376a7cbc60314d6d8ab8bd9d0641333cb2b1f90b441b3b9369004fc7bd39e8f49e2d82190bf259d010f65bf239f637af56476f7c47314fdb5d6ca495ce5fbe3e58509d6f4a1d9a02b25e96a942e574e7bade53bb137bcb488121598a0d9cc9929cfa5a32ed2d8c4720b661c879d28cc1575970e27625da59ab6306ebb5e309686ccfa77dcd69e938df9f7ccce180c108a0176e374d1218bc0ed1f2a82f56ee19dc09b40447b3eb0105bbdc72049a287ede837f56c98707398fdc2f245e066bda4039ef6d8643789668df6df598999e49ba8497740ef61fec53b6f45871aa2b2cb4f0c7297d98b1fe833202b737c45933bd11e932e0e9ede560aeb2393964ac1542da02c98f322094e15ea67c848752d9ac0f126c8c725697e483e677dca61e3d1c9a38b605f893436b910176084a7cc3e2942091f3727faafd048d74d17d11f51003e184ecd9d2a9649f8862f2cb4a4a049cc381381da3909a8edb9600e6278bb4250d20b61f66eb29173ab808b7f4af94ecc33faee74189318bbf5f1f685552fd87c6c2f5cf682d6a5c01f4cf509d3d902b4deeb74bd5e1134e607b4a6eb4bc0b54c41e2bb16ea45e31f8b7a059804591e35998f7268c40943173fadc6cce0cc4f428021b76bc1a5ba2c9cb4303f30a680acbfba399dbf8391c097b4d160cd2fbe3feac2fefa80a8898d3abcdc0dbdb21a5f1d4fbd333aeeddf57211343c31d4aae5a46938f28419c4d5366ea8828c0e75828aeff387a9f6eae000eb86f4f87d4e1347c2230bf7a499876e243f9e031edc87baef649a34ce24a0a182bcc31ee8e08afaae8a05baf86d1ac5d99a2526de2d6b4d0af2f340773e2abcb51592eecf61b30864e41e2b93ebd05159f4afa34a552cd2e1e24c8c19ca66efa7d2f39676ae2baf6429e10a1fa78af9869b1fe0f3831ea6798228412295c4b5d638ede0e256bf3208102893d4e32046d27ccb183f4d1172b4a2c408ab1b2d859f5fe8b36244bc37c7bdf3efb8f7d121e1ba2eceee4e5ae017ab98a5108540bb14dda8ab5f4e922ef56b09b416d2eb352e9f448581417d386986d2033a2e41a711579ca8c812786a719a0f467782fe2681808148461dd854fc81aaa34292d8c4009d134692d2b2d015f216738bb8e6dece3951da2fb84958dec9b6857bef8750b24640618abe3fad00f296ab0ce4e0a1f94394cde165d327afd1f7d52ae1dec988b24318200108ffdabf2f30bcb80afd67b7d61b59beb52bfc9dc36aba5a4a9210297530501f35e15e2eed41832cba99edcb5131ea0190ab3355007dc56bef7858f424812259bd0b102c463f6fe84a00f3759f489af9b78fde3494c68bf93e10bb1e3b1c6a7127cf66ba1eca52c614ffc6ffd906c6bf063315fff75cc136632443599f636f2b2181f5c78923884f09f1f0cd1a7827f458964c303561930bc519cc8ececaacd7561af95f612975adb1e10367f7fdee21d123b3359b6f9dfd1ab3168cd3719a72580204c8b333c288d32ed12a90e244007b3d0b3fadc7b65217561b634dae0a16512a95ae8ea42ada47872ae1055c10bfb842e5488d45b10e05010d4c76b18e389783a0587d9d62ae4b60444165ef5710ea6509cd84bda9ff66692db8373b1312d33c129d0d9d39ab960196fe02749262b3883a802b891ba2dfe9082fe9d4d92d2888f37764f69132beb3c589ded87fd06241702e850b1dcc4e1c95669baef0bf6b6340ee18bb9abbc80be596c8d998dac827041dc7a5cbaac50d13e9b92a1908c38379954830d16d8720d3843af3265fce2b1763707792c9da81d6bda7075ac2ca10ce7e80df7da66c984b97ce211fdf70881acd232cdf6bf342b417a7021676af16b9ed16c4bc165b5adb6f024d57860c248f9af10009b14a871f4b4d49e69ff4adc991ee5445dac43e91f52ccfa297b989df3e5e9202d521037ca32c244cda49f04c615769534a03c5e545175f5ae2e783eaeb4cc52f42d0537c50646317d6f0ccc5562d94f582d7e253857760c15ada416c468af3a82e771d284cd35fe919b562d503064f544456a50332c51ad994d5ea0b220b58d2f76c542a7eef3fff94c911de07be682e936648a2a114c90cac1a4b2d0abbd6022e70472e80bd9cd0208bc77eff7d95352872385645a9e0a81785aee8ecd2f056c4de2ef30a7744ed89743e10dbbe2c3b64dcd1c8b545dd0f78a1b029f5225f2bbaf230a3b03a2964c7945c3a46e4131f5e61fc2b988a9238fe4ff9a0ab929678669667d168fadb577264ae06a4775027ab0c2f39c55a93d4a08fdd6fbdb06bb059e6be9a9d0a3d13726da71375bafcf482294a6855a66724aaf9b8335c4c90cfb7acdbf96ff3e37b98bc7b223271490538c11eff3d33a4e0709500f83fbdb161f0a884f0986ce8614774ad6fe348e06b7c296818c0f66958c654044188d527238f85ac51e3bfe12f4969ed8a3ee9287d0167dfed0ca62bcca99892286ead35797797c34c4a9336100c13b6487f892fc89a1ed4e9080b5a712fddfe2585f1ee93d23b9b68f2e0f2e7507c34e57633aa59ce7f7e50a4f19deb086bd4bead70aedc90e477467214721ab135b26e30411b706bbbb1952f816e852ca39ce1afab88e845b753d1a4c74497bbc3d54aa23aa65e9e06acc7a2346e5d798716c22dc87a582eb0016e89c93d81857d073f414942d351e0450e0f84b06d82663907461c5d78dfd197f4353200c40cbf1bf01f71d82aec8bc443a3de4ae0b1eec626c5bd9567d1e6fe71b7f2c42f035ad799a579fd408d7d314c760882460fbba1ad9a4989a48fda81e904cc9dadd1cba8937c7a9798d9cbd6e475bef45d333e04a007dd1f9be3c29223ef574faa2690a7dbd252a4f0d04f8a8a53710bc578297f7ca44371c20e2c4196929c4e2a3c599dc7b07e63fd6eb66410fc20944316a40a858f40da4d00ab7ee1cb9a9fedc769aa0822b09567f8a1381f11a476c2d652d18de7e485c5396368886762bf5b4a3e09f0978844402358cd406d4de08d5a992a3d6caf815b283a4497e8f2366ce1a9e48bf524b948a12b82850edd0b1e66e00a9002cd28816b8409946d764ba4f5e1b23edb3000fb48b3ea40ccd3acc73a0cbfa76eda2fd9980582477f17cb3d9faea86dd5782e5101c4f5befaa50df624f25feca2158229b51afd1795cfe110565e8da60483c984ca6bfd688237116d737b634e91731cacc488cfd452a14c47a3678f59484b0ddf860a9946020548e357fa930612cf73319db107f5279a8e210f051546fec7d23577952f5849509214327ef1ed8c8003d9a00a039d4884f79ef5ef678f623b18ba8487b346a19d62b8af6e424e36cc5452d418daf549803e24d3fb2b0c7976bc37576c33d9ec1b77ed769ab1cb16ffc072f1c54be4c931da58ab3d23f366eb39c3d0eb02788a8f30ed63abf63fbb718d643c1d05fff67ec740e2a363abe7d9932a0cfbe8590750eedb70399383b9a4d687a987fa8d1a16a855e5d811857c9ee105424de8d9906d7311c466437b81635fbe3de40fcf9797670086c5c8f7cb299d750bbb99fee53b54a09284f107863ef4aeefe629d46763885d44f6dfb0c33dbc229a83e555d921601236c377e246bc24d56320e45c9130ccd9b9d1f7fe4f8fb57065c0314","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"5fac5dada27fd52bd5d7343e2bae50c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
