<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #00FF73;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #00FF73;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0E0F1D;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show"
                                title="Show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show",
                templateToggleAltHide = "Hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd3bb803823d1c226484265c03e0ae7d306fd83c91bfa32c1ba252e7c6229fc88e4f5830993c728260c29292b6ce5a4f6743394e3e06a1bf2e47e59825f78195939dfb7e4e62e151eeaad1db7a84da9717985138686b23471aa7794db6953f6e0b391a8e9561a1390386e9e3746bda88cf7c41c9b8dd244d979d128c428c43391800ba93c384ebf06f330afe570e4af0e1fafca5a90f4a03a01ae70946513eef6e5cebe03c32527cd4eaa3817632909d9a12f94eddeb7608e32266b822fba51fbdde8ca214211722209f4f6a72462f6ca47e3cf39af5ad7832eb93b88c4a0d8cda222b1341c40055b7bae24e791de305250674c2caac486f127a9faff58f4cc7ef4ffce2869e902cb38f3d215cada8f12619e876ea6a8ba9501011eefccf7a6e746971b700bcd910a407f305c13ed20e324dded61d21069d6bcc4cd5c914e5f03b09fdfa332267d6e100e076e6743cb8d49f8eadf366a341ca2d5998162f7dee86afa3ce0520b98ac04adf2192d37db3cfa76569b8e87d49060a2694f8135a189304dd9a3861e5d778108b7eefee20387280b2ba491bde848084bc53283367568b4a33d846682d87cdb32e39065fed1ec1542b8242d949c7c07c36e8ab892191abc96a420628d0958d7f9404a1aa5430b8a869a675568db17a186456bb21220889f1c53c85ac6a72c5aba49370761093dae07e488e84997cd659fe95ba8dd8305a9e58d05d79c9d88816cfd5fce7fc23a983c16d112a69268666f73bc514455307485e394ae4c357b83a8e1a02f3be24ac310665beaedd2bd4baad0538d736cf95481f17db4a65ccf5ee92ddd5af7443ea8c3e78c01334ed950d8683417f23b69ed776f4e4b31122ed779f905fa27f2d909384bccbe2769d89d94e24313d9204a7d4642f524a50c8cb2fc0ad98a530b00edf32a7f1ecced13d99f838b1df13a85e1922e51fc03aa934af5a882b2f19b5b3583f86087725961a6a36318aba8df0b3e717dfb75fb4870fa1c0d0b9b8703d23229a717670d3d5787add6aecc67ac234a4acfe9334cb9b0f57dfb4bf0adf97c77b3462c9446d8d1042168bb93321bdb75ea50722f1ea279e35fcbf3b437232b4b8d0f1be65cafe9028f3733a686af2978179c3af6959e177a3007403fc33b0a9b58c409d671100031c03a7675979117f1fdc0896926c6c7dde47593633a0eab0cffc80a9de9511993e6b3664b79d4696f5650c68214d704dd91874e274da0d174efd9dc1b799ee01dec8aebcf556d7513442907acf5dd49bb8ffb51c3937a2f3c9bd800463b54fff673660caeb446e7ca9af3dd0cc6f8606848b621f708bf0c360cd9dc2cc416e151ea2cd7075597114375d821a74ad7e9e75c191b7cfb4a9d832bffea1542c3fa1d0cf2e68235459dbe1bf554dd19c3b2850a3fd0d36836bf9865d1123fbebda62b67564d3c534e6fe411f963d68f61f76bbf5dbd9ffe28283132aca7ea72b5c57889b489d4ab70d0afd37f0becc33fe0cc0da3f3b14d99549bcc9bb16e37c948c48855fc8c747c2c5f3b2451da42602a6b65d76c1728b9ea7b0fd56665ac83bb89bb400483f166a6cf65462d180003b7c9fd4cbada13190755d309ec1b0ce48d6a46b62d8151732c5cc97f347889693274f39c2616d957e6c42a6c0bf7ad313f3f0817285f142a1d5f45af800d10801ade3cb9d8526717b00ba327ae47e2a3063e6cd3b223d981a845c673208b4f4af35d571d0ba16116cc93cacd4b8c9f8d917551cd5a7160e8a5308e57a883b5899b8bf4d08b4e8224f1e835cbfeb04df21c43ea0edb56098c42561693a1ce003ff7067a970d9db32ce02489d46bb5a04da8f15a932e7ae2f68702b0b3b72c765e3611f1a9c7f48dba2a5590343ca8f243d19d3a468baaaa59457f285de307bed37064972198d729b53bf6e1be96e3dc2f3d869245916bc8bd53c526a47992f4c79b71404c03e692f4c6ab4a01eff5593bcce9e36da301cde10aa13f01689158e0d252830ddf1f6af7db013adadfcb7a6d1d50cc287049620e1f955d7dff46818ad53f8f447160e94ba8ac43183bd56d7588c2f776876d24b27c73649637592367cb2a101f1afb04c430a4146ddafdff80221ce128857f0161094d19f8a67629d856e169c976e262fe1649f3ea84387a37392f515a1bbfa5cd366c412c49102cb77cbd5ab9c0a9cd5cb58e239a33482c2751140744a0cd48e721c67ce6b70b0e245295cd2add7a36eb11e077b1093380485c45848480954de1cd65f77094702d9b7c60fc73c6568fba25252b3efbee6d8a69106f18259c1fa0b6aaf369063ef273b69e332411e8cb85030babf7a86dcc71813964d0cda1b41de0ca665f6a632fc9e1b923084aa851cee444121fd1710c5eaf0517f844f5089fb5d7d6d7d6df78f2c1a2283f15f1f5347909b2502ca4daf0dfc1bb64dcf027ec385e319e5401a6fe0718c22f42e5d5d1ecc0572814d10b11fb0d6cd04d2f5f089542ab3909be5cdc5715962c018e57dce0ca5fc136360e9b4f648b2dc9f460f38cd13481f56c3d832b04f6fc7194b79ddadb79215986ae5847e0a509afa1106f998e24b049467a1b4ef9d67adbeae140dc9cb5c4c5ab984aafe6d103da37f0eea367908ef40df9291eb2d8c6f71782e5fdf128b946796c1db4b11bd09600fcff7b93bfbc9e2c222c266f4c751ce90029bbab1c67648f4e40728b5f78f240b0ba626d20498f6bb69cdd93a0ae25a97818c5571126f20b31478452f5ad8f716ae5b17807557357a680a030ff708dc53368b7d6c7f3cb50fafa0f0086729b1a61a4176ef4ec96418e26ac513c5b9284e636446c57429bc99cd12bc72c76d1c790e27ab352a9603fec32d654c283a2b7f7a3ca82105992303b86e6d31668697a3c552c8668be76ccdfd766989b62a024753831d6d72e7c27ee409be750fb12debea4c0095f59932072467ef383db22c3d892eede1306ccf396e46059fe5d8a5ff572698c4a8601c6f44b6e7626c46ab0eab532dabbd2d422f5b41b180c6c65e8494396233d674b91dda35adfb5648de1a3dda6345464430fb81bf912bb324cc9bc0293353cce1e530ef92ca3ad12baa20a5c8920b90d30599dbe5f18d30fe8f7fe281435069b3e3407ce9a950715dcb64a61ad476c0238dd5d69b069bc4e968aab2cb2405e34af3ab97c26078db2f7686462e49b4dec29c97f46d0faa179f862f82a5c47c5b3b588dbcd38763b0def04c80ad3656d43ba6335e2b167cb762267c57b158486f754edd1d8be2d626bbedc64b47dc19ba71c82adb3291e84ffc7f30452662ff8565c2e7b2366a9c7d47fddd493002bae07f5d97f6d6992cc051b55b0234801c75d827eb5ecd3b74661c046d3a09e97ac4a757d99a5e0e924d4db0a0e9cce5eeff6145618faebb3b3cb27a470464314f4c19fab5086a22fd8a67300905ccf7d89201bc3c90faa1bc5f05ba068725823f9c6266e6fe1969f159c2571d60ac6aae9ae9d5ac30ecd9834f1e7a081ecd2a01057da8b1a92a680c83c638fe5052b728711865bd8258759a689232f83bbc0ba2e76fb1bb2f293372aeac861977be26fa8b8549e9900eb7115d219bd597d66c937c8c546b5e118ea12dce544dfd36adf9f0f4de7a12206990408ed70dbb39226950c6adc0988e6af32a62a76bcc5d4a2337fa973fe0eaf65d090b16aa469f3c921b0c4bbf6c3782c7c7ca4f392fb160a15df07db3b90f3ddda228ba460f6a56695922afc46110f6a16b38386114ba9fd29953954a81cfe0d83e36943fa41419fd48783eb4ed792dfb537daffce16073ca79136b3314c17e51d9fd720d79c2cbeae92f1ccce604d32bed8b6f8d8c67d8d0c6a077f29b52c83d1b6d23b26ef7242bd99b866562396ffae206291403d4816f6b8a590b51b767597c07a312a65b10439d4e4d745eafc1d076f8051a780fc6598b590890d6f236eef3a9ab417b4eb086266175e4c513829581a7163e9058b6254f8bc238b08154f5800acd06f4f0f1ee99403b27905a9bdfb0fdc81e2facd1a87fd1fe37d9b5c7f2cf3fa49517a11df6242f7dc70fe77e7c23e3e7fda2c0b9b3ae343a79640b3fcb4c1dad034aeabff50ab03c59a5fbf6370a6ee716203059c42a05c886a4e4eaf50594c4acb3c3f01d4817224acfcebb8209874cf25d8088a1f1784454c436364db6eb30e958a5e8255d68d0b3897130930de78ff34b42bf2d8b3915e56ad6de80c38066cacdba297c1c01420492a824d5fcb33394edd179d4d82f37fe7ad21c5e5eede41a62f60e9cc74f6aa8a77559952f5443c15bfd412771b4f7a07c3908c1059c6adfa3958c89cbc1cbd4e0fb99667626a822b52ec709d59ec8beaa3c67c82e519395807e4c1f8dd540077ae347db66d739f9e54b8a05686ad443cad37a6a99af4a0a27b326cb588944f7dcb9ef1d7b08ae1e7c97851935f1df4c690c09f52b03df81515f9f326c25ccfcc3d5d582bfc470415760a0370813376c9273b0995f7690fa6021cca77f061309103db6179c3379349458fd04f728ca4aedd9ab8e32128063ecdbb04bac729305591f2a712b7a1788d3760212207ae5ee2845e115cf65c4cbaecbb3a67f2fac65bc996db42ff26a6832d39231e33be811c51a4c752a00768bc224ab83aa6dc971cf2a31c0295230462ffce82368e813ba7330f185ff716eaa2ca97b2a1958de85a0011f3f77d8ef9f90968684e6bf441acfde5e224074b324a0e39ab1c516146ee84ab7d34e1e270d19fedfb71261dba13b9466f3ea1719244dbc81e25711edadc9c2885bca237e4d910992e51c075ac4b3d470ff2e50deb7d1f3b0326dc086fd151ace42772f8600c8ed710fbe2b8a3cfe954ff28635a13dda3b5af46eff073d3c6015828ec0b6dc3ae5f89a720eadf7484b8d6963324d51ed5fbcc2606fb0b5700a608dbab375f8804848c267b7e3136994d82efd807040bb6e41b237a3fb11849f2399f2943877a3365501606a8d6ee9978bc6e5830422fffc6935786031fb2973399727a6da9fc0d819112235cf3315c896faad90119534be5cccca8cbe0e647ca477226979fe1f66ce55327d732d488fdf1014177af22ea1838661947b7f3272f4d302b0d06b5358145735aecb16ed7f836c6debf9bc71477867a4b662a22addc189b3ac650919bc05282fbd3c1e480702d218ff9e4f7313937da9a2061635a13a23ad24d28a591847b2bf69b372294d8c789245366d0884fb0fc47b14dfbb56bd128c0c7f243b61ed629f42c45468b44d4574986a8448aa3466dd2063aa0385d2a1c558d29e6334b5b5838bc47cc4d92963bd6e8965eb4d903421dc4f0140d60b4d5da4ef9cf655fdff76686d8a2606e43abd9ae75645531676d84b49b7c783d3d9f3c8497b701dc8193f8491a3f05f84678ffe485a1352b1da08baf73bb3ab48fc19257261ce747ad9f2080b6e365230b8078e342cb4d280fc836838b197db2462d3bd4bd0d3c8bee90570898ab6894996c28582167e44338554de14782314c6bab10e24633f086380bd34b1a9b5a7464edfe80f8542f952aa3d0f962901329b9962ec024cfa81a64a6ae6e946611df67157f928b71b52ad682b21434ecef6906474adf9573805665a7c42e89a876ab10f9a2237d769f8941d3bf5059aa3a2e995144f25d8d0cff29ecee821f570b0e96ba28fc4e2ed7044bcdfc3372e22dd6329200421ef68278118457bffe575e927d0d71bc8558707888100d54218dd9b70b2a3cdd86836b6a73dabeec170485b336eb30f67c0c30d98649bb77fdf494d9547b43677319f335e43feb773e3937298deb8f3c00051bb9f20d8cdd72e956a56da5d08dbbb7c3600d1d5e6bd3365e5f0e7fc72fb264251408544a59b943538862cd96d120fd20e8f2ac1de55d47e24d5b89f69d30515207d10369615bed5dde9b1e503ee01442bdd645e24afe63e6800f1b308399fc2485fc6164b5cd2a8e8e18215cd06a021206e27928ca36eed9a51041c9794d802110b8e5d5456c1b1541399b53d624d2f94b1bab1c2e7ea319ed1b19d9f5785cc85d85b43e509137ea2224f083b604375a45436bd019dc81b4618812cc867b1e8db26f2450b08c21b7cba821b87c819a269091fb198edc2684dbfd1d3a34a38be219584c6082206223bfb1a61612f164b71484529c8d128ba9be719b69980f8f237d09347cdfd23a4671ddcea04e3495ac5ad2c2def77cb41dcbe9545be139522d2bd9de7f7719d5e80b2b67a61a91c32ebfe0e8e0a25ab3fb08f419d7b7ad68c6eac65d60ec1736a79fd553635e1776952936bd4ef9a2e90b3245ef71d48b8a3565f359a8278f2161737a4958c279f767a6411b4c9c0d4c22fb3f0ed5985a6c71e4c087dd3daf42baa6ef4f369ddd4d3e39819e910e55d754757de9a575e2d350f932fabbfced9425b89e0829b4772a15cce3fc79f74441af5055fd48373e0acfb2f39cf827c225b7dcb400355c59331e46bdcf0cb8a80cb29e465e360610b0b86c9062c384f066b790a3d5137f7effed220496716879ce84ea23dffdc49fce4f683502c0863395ab15e961cd9b676f149d1611493fb203fb0dfb8a5f923ba8b6aef1c482629c41227fee9c5539c9ba70769be37567d829db09d3c2b5736a0fab68396d61f061af6be3a95badec66b207aa1a924174b3e927193f16a810dfcf97d363bf30a3199bb282ef800a572e2ed5a360d1e03ecfeabb13f1a01be5c40671b4d8889a00bbf3b8fa3c3e123eab91bf94b4feaf762c5a4910a6657f792c31787241e33ed8e9dae9c91f3f8d1fd71fc59a749a24699cbd3616f8bb3848f1c8788f94455a939df87b3120a0641f10d6d5eaf2fc2b86b983bc3f6f12225f2d1a4e14a24b1f4c95b22d1324dd22a1e6d9c7f0e1c04b205a69e8e5eaf8fdce56bfa819e77abbdcf6bc6291129a962c4939664678cd05f66741c6af6895758cea18d56fc3f72b3f2e49802cec6482fbaaa5ede32914fc87725836ce9aa90aa2f388f32123b9aa77cd6d53efe01d13ec67d62fe1dbb8f61b2898abb9b3d159c475e052e65ee63c91f8041c7188c631b48defffc580f9e5bd064f3ef7f128b3e92b35dc7a4543d7bd8189a1dc00fd50721ef1aa5da13f0a2bc8a342367e008e20e4f4c23a82bf4afa707ec4e10c025c1003e36a3d5e9b63dd3fbca9cd4371af313f09981f9dd20ed1838ca473b4786d835e2fa6b9ec4861b547ce1740859214e219122135420fc3f3e3180ecaaeb977c2787d0e9f834df36dad37eec32ad9965814d886bcff2473a2b0a1af68de3825a86b40e44e79ca2a205ac7c4a66a7940a8a65bdf6bb08f2680562e23e110ec4ad2e0ea047150a0d888b69e223970ca6993e634b2740981a9caff60feabf541d683c5a029fb123ce2596bf5b25a38d6d32fe9d0b459bf1f4d20ef8e53afb42e8860711c14af29587ea69d3a39ca14a990153c0bb8ffce9eea8f5af0a85f28c04aa1b9dd54cf4ed13c0e31866dc617a20d97cbef373c6778a5fcdfb9425623ea79445822bb4ca61b1bd9a988586941cff0259724f1dd2810afd1861ab4587e9cae25315e697d7449b2a8a95f681ce7d163ce637e82aa30b46892637326c3db1aa52dfa896ea624a364f15dbf5e8537189441c131650603fb651445e05e2c1feeabb15c320d8dd047064217c836983e0f0aa579af9281d07f81c07e0853509f1a10866c69698b9b7df9914e1df88c70c4e6e526303059dc8a3af3a9e1293f522dd6e56d217c855476eaf052dbd4685c7a76cc7810b38ae58601665d6b33f55654183719b0cac11e3839bd7a8659a04358adf0225dd0a2eef7c41816e18b0fbe5141e576512e33ab39218f600642b4f21df5eb7f552b1c9ef8d140a3edbb3c035452cb1371aa95a6bdce5920399e6e5f0e9d08696d602a1f599fc6e5f2e24f66afd6d29bde70ab9a1e0b20c3e4e319484b12a22f1cb57c57a02449caa83e5c99b0060475e37a44ef5a2a1dcf48c8c6bfc6b6613a9e3eeab7a57d7e33511016eb4a1f8a77f4bfeda8ed300b69765b18b4f544ba5afd255d60986e082a989e838f389bebbe1451fc6d97a7c595d736b16df511a2fd36de716894b6b47ea19881b19934d212a15bb47d73dec6c87e57c898a2f9ae0945e5aa376f80aa36261cfce70359d5b65958bef03fe39a05c71c6e5ad76eaf14be1c4f2185778bf2773b37924bf54bcdcc2f0eb78b8fb27f420a980b21180263d2144e0581429c01fce7a734f27ead62401c2564defc4a19e63f2ea448da10da5b519263093e4265949770af4dadfe5bc4e33f3441f29e3ff353432a4df02bf3d51cc2267e56d8357c7a839f0990ddff49d6b6ed7e020e06413ed9db5bfae7c16db3a6b2d692afc9f12b93f96c1255a3e6c3f9128d73ede118b955ff757db402e98b2f53ed3f0ac096f51e8c492e381e7df215febab1d58fb568c6e3d7a286dca4364a36630934dfccc9b80646f987e371db34fb463f33dad0f118c01cae06f63c3d55d9d3dbdd5310f4de47ed477883b4ca4294b7fa08df4aca361883ddd74fce96d834a7edbe06a5cd98b7751a3d53ee3e6bd16774b1931316f9ece002f5090ada62dfbcdf834829646ce8a46861e854dcc07cdca53d3731725cc4947b03d0c1b12fada95951fd58617a30484e7c48774e7cf6ef1825a024210520678396e24d0ec914f39dab52210e02fdb955170c1897a9590e60fd3ba38a10e6591eba90f3abc18ac5834ad64cd1171d1ea29f9a5421775df7fd9f3daf90e211a7ad5c2473e68bdd9a631ea1e7210969aeceae96527cc0428461467e7bed94119ac7a37bb73a49cf6b316a0cca5f3aa8d305c2330bc7276f36f2ea7cb2e6647074d3a23a9d1af9d53b8fb97b74b727571c2f7b916ec7a75f52bc36ac8f86093a5e6c5c1fca79ffe8b1ef6ffe523d099c5cf19bc956e5ce7832ce9dcd22ee46336440753632a3d99e6b1fe69fe2d5b735b131bc595cef506dfbe746f8654b888636f82ef1c9af3d2613370e6de629b4df26ebaef1612454cc7bc75699b0d2d2d7d21206425302de5f3a25500463ab367f5c74cb3753157270364d936eb8d2e82f3351fbcb125a0ca554893960f267ebbb134d3e2516eab2e0caa1c4f2fcf9d217c73a33f9bbc7c908264cb99aeaa760f55b7ba914cd395c3717d9ce81af58686755b45e3e07cc7a9510b06a42aaf7b13426a8a00583cb078a89f73fd133bcea1a2993e966d97fcce6be4e1390174548f2e7359fe3c91fd9dd1b558c3a3bf0c62292cb44d4fe762c02d1cfceec3158793c4bcad3af988024e650521e61069b623b2b30bfbb6b84ae5c5faf98fed042860611a88370e43e3b36d3a29daab1db4fe905b0074a830a65d8f6f27cff970d07afb0fe38be7f6aaef84d28c9122555eb5d00a8ee8d299d145cf868f459b9ef56b8741cd1fc8a4930b636fdc4b8898f31165b40d61c3aaa574a3b6d51a75dd0c1637e630de2524d75278036ec260ffb1c6c470c30878745ba065c2ceca997ae268a7cc30e154506e1fb58a87d2e88bdcb7d7223c35a49702c292fc5cbcdeaefe527e24235700f013fef6e045c9a2067ed86fc3d4d30b19356ad4068833547dca791509145ac8460a0a0629261c6ca1914d876cf9926c75fbe32ee944d48a83fc4cf374eeddf6c88ad8220b8c5d5d4fa98e438b6da7c60386f99ed8c2079b9e55f7e3938cdd15dad37fb79e5b2d36f085f090cf94d5b78ac8c11198d287b01e283e097e256eb7b87bb4ec57040ed549478a9f43ef18c163224d74be800866e7574c16d0fe2ca39f231040d6a4b24710c301af7d02f4e9172b40a5ad53358b1690b59f1662e58d2fd296c7f6e95197e950a8b699f7b2aa80025dde50ac36f3008416d33c23f501339717bfaf9294a3a9bf930df55e2d3320633653c1b74f14c67a7fe54a2dbe3533b06f483cb8a7935e53ac9966d6714baa1ce9f72eb33978254847002fe366e50e8876a16b46b1d80ccb35134d6db8a7b0083e37560e62db751c8a630f10d76475f058c33e9adcc3fb1b64e46d674b13ac95157b793c774f9000a297c6f6980ffe8e53d0b3b05ab0d80f62894e967996becfc6e267283fc02a3e8b3848a83729540a9c061d69c080ec504dbf56f32075f456731af63220688e72c865013b6701f1e14edfc072a82542ede93c841ed7eab6f2e8629ebf61599f18513d7f158ba441e99ee18a00915b6f5133c0dbf92e3d3d3921efca8beb189e91a659e32d19acb1ab279f0da0bc48ed826f100c5a73ed3e1f469338c932594d4aa34a3ec4e7600f749efe0993c0e82a9f6f52f9fefb5fd123e01545b2bc61f16ea325c62aa4a05d08dd75c525b1613f956b60482209de44051ed3e56eda1b46cf9a49d1ca6950782124e456f8901372426833b6d0e637d0974a3bda4f89ba8a41268a1c7e4513469e7cdff1b103c33447117e9c833344f948a6c18c4d9b7aa21268965feab4d7592ed42ed56ee3f01a7d3326b47504caa3850a37b65199a3d6c412546f00c4c32b684348056fc3a38243cbb09c07abb1eb751813470df2f3a22bec432de29ca9e11dde0c36992d33695f1f21c0435d4d3ddc0e5da983002680cdb88d5c44ef68ecc32d69ec39ccb5e4d87ce1bbfbdd735858960760afd990ea7729117994833b5b7bd33838fe8137fafb4698686b66bdcc04b665ff4c884602a34be1bd0b28bc555205cec749cdd8adce3099d3201ef84c580d29235ec8fde4191be66cc3d1761e5d5c4c693ab269fecf90b4f4ecb432df658927c65674db87e96691c13b50d69a024a9731215e9a61952f1e959770734151ffc0eca395bda897195572ecdf494239bc4dc5549c1611111744bac78b0a448a0828ce70bc00f279a8b8eec53648a63824bad18c2b81a825ff21198221c28623eb9e4ff8fb1731552eed184a4739f102b19adfd66919bcc95179a4856f7db12d9c87665bb100aac9235fec31c8b0793b0ac56dec7655773198e4fc72381e9d9815641e4d8358245f7a9f7e05720160e2fe9b6fe9ae5fedeadb06f5156adfaa2b64f3418efdbcc7462be88a310172da9b907728d4aea86ba17fde66c3fc87d6775e9df22bc9f96074df5ed73ef54127e7e263ce5b6be4a7e6f26f09a251de283e59f8f2c5a02be19b9afcbd9de7af072a54d2f97b6ecae49f85ad427d7fe1582a53d8bf9c786a973545b986a75dd054c564dcf6fddc6cc765cf742d07eb06144d50dc6ef0cf1dad11ad6e9f8803551031d9dbb3652923cf2a97ee318588a139b662c19f3ab007fc1fbaa852b12f8cfe37dee9e8edb26a82e7fa78a14b93b886f7109fde7e8f6f3632f353feb9d5930c615a68d39048bf04152470e9e066273c9b9bb63e6e2eb82daf2de0c962626e973bb903c70f698f38137145dfacbd6c6714d363fe917c459fba69ee17181ac2282b58b6a4b4b06622c72cc4922f84c85d2f8edd5db218ab5db8605486b07b5e9d5ed007d36c390a8259be8e4cc0beae3ff3253231d1c4367534768e9a100e661c25b2161c060cdbbb5aef04bf4607759479619d4080a7c7376972f6c23c5f24eca011b69731438b47ecd48229e0a26fc6a158861e9ae209bea2361a1fca1591a7e3c666ff880cf1314bc6960ee8c3335207b8afc3bbb110d0e6193d6f93fbc36cfb012a8731167fae1c451e05f785f46ecec901c2cf7baacf0d8aca7d9a7fca418bbe999e99cf7ebac7013c81270d6cd4caaef478b1cba48310d7f147bd71c0c44b65ff7518bcee13b4ec08ed145a5c1bdff1bb88aa884eaec04470ddd56fe66dbb412faaae91bf54dce49879568ed60e226dca2394a552d652179e8fbecd4fc43cf5855435a95ea0581980e811f258732a0f8464dd9206765dfb6f9dbb373444845bf351110b2d22db82a03b52d255c222cb7283382783ec4cb2949277611d0acd7ee195a2cdb9204148e1e642b14416f0d3efe85ef3ec07921bd1c0dd6cfb6e2e0f07751592f90ec666d9f3f4801be36007988d4fbb4f46aa17d77d373cca891ab1e51f7565ab2f13201e54dc030389709b9c6475144e2efdb803e4070f504473a0dc3033e871be3e82cb5416d0dc2e61475fba7698a89cdbd8861b51cb57a3da880594eb665bfff9c22943202ec4bb7c79c8e1b5c928149fd47cf833ef9d4d4987fc08ba54c2e105656d7d4904880d341bc427fca965cb9b4282c8c92c4c985d865a86fe418036a1cc3744ccab8a11ea4d75873632c17897a4fd888a87f1618a8ece5b207480537c175f7cfe91683a76a6f0382f83b0da12466501bf83724dd014b5217e5476d5cc50cd497d5b871bab89d68f8f1115d7a5865c12440ddd1c88daefb9e2e09aa3d0d6abb1905fb8f68b0f8362be34b832a8f72992b9f626f14a95cfc3c2ac2c80448f8537fe4903f587c7307980d4c8ac124b387fc7549af59f6c0bc5c79114a7277061ddc27e5712cab682096c02c60b8d5db35eb25fff16fdd476036e650a6fbc511dcb5f0395425f280784c1afff5209a86aa1ae19cd6b25f6876b677262b2b6ff509496d27055111f58f668842f75e2a8704e1c3e3c180f4d9649d0d43bee462f2bb12e8e047a209eea2d29d5177fadd582a668a752a4f16a7326c9931d8a8622457457a5d22b927279a12cc5b9e4ea8d0ff856ce76df8d9b4c130b52b387d923da08eeed576a7a7eecba7aa9db508417d2df5113926c087e8cbc7d298fe9a4807e04daee8017ef955c2d86a0bd5d9cda90bb391a8ef0ff462caed1fe7e4e1a3db0ba9b968ddcae26ae41753e06ed574dfd95d6acb2fe24c486257c2f89bd80158d4ef22462b138947b4d0b8431082e51734a209360053a97b0680c4d8971452e4f99ad3e33efaa612cff65b5306cfe1eb7be5ddad84374385e6a485685f65967a433cb1bce4fe5f18bdc999d256428b7b29e5d1cd6ecc1bdc5f72f30ed75907725cde69ad2631cda1f5253b9d7184bb58ed5cb5f9657d1ec9605d9b95314b82afc021f56b173b0c0efbc01cc7aa099552921b04d10a78af474b6a4b317b1fed242e0d60a49b8d6fe1c4d37e8698e4b19530d19d20c4abaaa29926e3a2d3ac23147f247e66414e5f2feb4ed941a478b71cc60fbefc06f77e16ed4993de0dfca840cf4942ea3ab86d01cf9da6e51a34a97f65c4faf1494e94acd4332d13d5c7f29f5030eef75482e615127275c89d676a8a8c325ede2910ab5856e994a652a3c4c51382272be9b5fdc969ec72557f24bb35fd8a25987f4da820fe906ca4358bd206b4de1834d0b04471d6dba71a5f3b5f23c04a7c22fd699393a088fbc15d3188db5cbbac0fc796d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"5fac5dada27fd52bd5d7343e2bae50c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
